<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Blog Entries :: phly, boy, phly</title>
  <updated>2014-06-09T17:00:00+0000</updated>
  <generator uri="http://framework.zend.com" version="2">Zend_Feed_Writer</generator>
  <link rel="alternate" type="text/html" href="http://mwop.net/blog.html"/>
  <link rel="self" type="application/atom+xml" href="http://mwop.net/blog-atom.xml"/>
  <id>http://mwop.net/blog.html</id>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Better Understanding Controllers Through Basic Patterns]]></title>
    <published>2014-06-09T17:00:00+0000</published>
    <updated>2014-06-09T17:00:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2014-06-09-controllers-as-facades.html"/>
    <id>http://mwop.net/blog/2014-06-09-controllers-as-facades.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p><xhtml:a href="http://paul-m-jones.com/">Paul M. Jones</xhtml:a> has started
an interesting discussion rethinking the <xhtml:a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">
MVC</xhtml:a> pattern as applied to the web, which he has dubbed <xhtml:a href="https://github.com/pmjones/mvc-refinement">Action-Domain-Responder
(ADR)</xhtml:a>. If you haven't given it a read yet, click the link and
do that; this page will still be sitting here waiting when you
return.</xhtml:p>
<xhtml:p>I agree with a ton of it — heck, I've contributed to it a fair
bit via conversations with Paul. But there's been one thing nagging
at me for a bit now, and I was finally able to put it into words
recently.</xhtml:p>
<xhtml:p>Controllers — Actions in ADR — can be explained as
<xhtml:em>facades</xhtml:em>.</xhtml:p>
<xhtml:h2>Definitions</xhtml:h2>
<xhtml:p>The design pattern <xhtml:em>Facade</xhtml:em> originates in the book
"Design Patterns: Elements of Reusable Object Oriented Software,"
written by Erich Gamma, Ralph Johnson, Richard Helm, and John
Vlissides. Over the years, that book has come to be referred to as
the "Gang of Four", referring to the four authors, and often
abbreviated as "GoF".</xhtml:p>
<xhtml:p>The Facade pattern itself is one of the seven structural design
patterns defined in the GoF. Structural design patterns are those
that provide a mechanism for defining the <xhtml:em>relationships</xhtml:em>
between classes or objects in a system. Specifically:</xhtml:p>
<xhtml:blockquote>Facade defines a simplifed interface to a complex
system.</xhtml:blockquote>
<xhtml:p><xhtml:a href="http://en.wikipedia.org/wiki/Facade_pattern">Wikipedia
has a general entry on the pattern</xhtml:a> as well, and provides some
other general characteristics of a Facade:</xhtml:p>
<xhtml:ul>
<xhtml:li>A Facade creates a convenience method around a set of
operations, thus reducing the complexity of operations.</xhtml:li>
<xhtml:li>A Facade reduces the immediate dependencies of the calling code
(they call the Facade, not the underlying code).</xhtml:li>
</xhtml:ul>
<xhtml:h2>Facade Example</xhtml:h2>
<xhtml:p>As an example, let's consider the following workflow:</xhtml:p>
<xhtml:ul>
<xhtml:li>Marshal some objects</xhtml:li>
<xhtml:li>Munge some incoming data</xhtml:li>
<xhtml:li>Call a validator</xhtml:li>
<xhtml:li>If the data does not validate, raise an error</xhtml:li>
<xhtml:li>Start a transaction</xhtml:li>
<xhtml:li>Pass data to several different tables</xhtml:li>
<xhtml:li>Commit the transaction</xhtml:li>
<xhtml:li>Log the changes</xhtml:li>
<xhtml:li>Email notifications</xhtml:li>
</xhtml:ul>
<xhtml:p>Now, we could just write the code:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
$db     = new Db($connectionConfig);
$log    = new Logger($loggerConfig);
$mailer = new Mailer($mailerConfig);
$data   = array_merge_recursive($_POST, $_FILES);

$inputFilter = new InputFilter();
$inputFilter-&gt;setData($data);
if (! $inputFilter-&gt;isValid()) {
    throw new DomainException();
}

$db-&gt;transactionStart();
$db-&gt;insertInto(/* ... */);
$db-&gt;insertInto(/* ... */);
$db-&gt;insertInto(/* ... */);
$db-&gt;transactionStop();

$log-&gt;info('Finished a transaction');
$mailer-&gt;send('New transaction')
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Straight-forward. But imagine if you needed to do this more than
once. Or if you wanted to re-use this logic in multiple places in
your application. This is a situation just waiting to go
out-of-sync — and one where developers will come to rely on
cut-and-paste for doing it correctly.</xhtml:p>
<xhtml:p>A facade would wrap this logic:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
class DataTransaction
{
    protected $db;
    protected $logger;
    protected $mailer;

    public function __construct(Db $db, Logger $logger, Mailer $mailer)
    {
        $this-&gt;db     = $db;
        $this-&gt;logger = $logger;
        $this-&gt;mailer = $mailer;
    }

    public function execute($data)
    {
        $inputFilter = new InputFilter();
        $inputFilter-&gt;setData($data);
        if (! $inputFilter-&gt;isValid()) {
            throw new DomainException();
        }

        $this-&gt;db-&gt;transactionStart();
        $this-&gt;db-&gt;insertInto(/* ... */);
        $this-&gt;db-&gt;insertInto(/* ... */);
        $this-&gt;db-&gt;insertInto(/* ... */);
        $this-&gt;db-&gt;transactionStop();

        $this-&gt;logger-&gt;info('Finished a transaction');
        $this-&gt;mailer-&gt;send('New transaction')
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>You would then instantiate the facade — likely using an <xhtml:a href="http://en.wikipedia.org/wiki/Inversion_of_control">Inversion of
Control</xhtml:a> container to inject the dependencies — and then invoke
it:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
$dataTransaction-&gt;execute(array_merge_recursive($_POST, $_FILES));
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>This code fulfills the Facade pattern: we're no longer directly
manipulating dependencies, and we've simplified a complex set of
operations to a single, unified API.</xhtml:p>
<xhtml:h2>Controllers and Actions</xhtml:h2>
<xhtml:p>Hopefully you can see where I'm going with this.</xhtml:p>
<xhtml:blockquote>Controllers in MVC, and Actions in ADR, are best
characterized as Facades.</xhtml:blockquote>
<xhtml:p>You can define Controllers or Actions as Facades for the
following operations:</xhtml:p>
<xhtml:ul>
<xhtml:li>Marshaling arguments from the request.</xhtml:li>
<xhtml:li>Invoking any domain/model logic, using arguments marshaled from
the request.</xhtml:li>
<xhtml:li>Marshaling and returning a response/responder.</xhtml:li>
</xhtml:ul>
<xhtml:p>I think characterizing Controllers and Actions as Facades has
some huge benefits. In both <xhtml:a href="http://blog.astrumfutura.com/archives/373-The-M-in-MVC-Why-Models-are-Misunderstood-and-Unappreciated.html">
PHP</xhtml:a> and <xhtml:a href="https://www.google.com/search?q=fat+controllers+rails">Rails</xhtml:a>,
we've witnessed the problems that arise from so-called "Fat
Controllers" — controllers that do a ton of work, making them
untestable, unreadable, non-reusable nightmares. If we think of
them as Facades, specifically for the three items noted above, we
focus on the specific purpose they fulfill within the system,
giving us:</xhtml:p>
<xhtml:ul>
<xhtml:li>Adherence to the <xhtml:a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single
Responsibility Principle</xhtml:a></xhtml:li>
<xhtml:li>Adherence to the <xhtml:a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency
Inversion Priniciple</xhtml:a></xhtml:li>
<xhtml:li>Adherence to the <xhtml:a href="http://en.wikipedia.org/wiki/Law_Of_Demeter">Law of
Demeter</xhtml:a></xhtml:li>
<xhtml:li>Ability to unit test our Controllers and Actions (instead of
requiring integration tests with complex configuration and
setup)</xhtml:li>
<xhtml:li>The possibility of <xhtml:a href="http://en.wikipedia.org/wiki/Hierarchical_model%E2%80%93view%E2%80%93controller">
hierarchical MVC</xhtml:a> (usually tacked on, or poorly
implemented)</xhtml:li>
<xhtml:li>Clarity of purpose when creating Controllers and Actions (do
only those three things)</xhtml:li>
</xhtml:ul>
<xhtml:p>Defining them as Facades for these three specific operations
means we push logic into specific domains, achieving a proper
<xhtml:a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation of
concerns</xhtml:a>. Anything that falls outside those three operations
gets pushed elsewhere:</xhtml:p>
<xhtml:ul>
<xhtml:li>Models/Domains are invoked with the arguments marshaled from
the request. If you find yourself calling many models, or
manipulating the results returned by models, you need to create
Facades in your model/domain layer.</xhtml:li>
<xhtml:li>If you find yourself doing lots of work in creating your
response, you need to create a Facade for marshaling the response
(in ADR, that would mean encapsulating more logic in your
Responder).</xhtml:li>
</xhtml:ul>
<xhtml:p>For me, thinking of Controllers and Actions as Facades has an
additional benefit: it describes rather complex
<xhtml:em>architectural</xhtml:em> patterns in terms of <xhtml:em>basic design
patterns</xhtml:em>. I find the more I can reduce the complexity of a
definition, the more likely I will understand and use it
correctly.</xhtml:p>
<xhtml:h3>Epilogue</xhtml:h3>
<xhtml:p>Consider this post a <xhtml:em>refinement</xhtml:em> of the MVC and ADR
architectural patterns — a way of describing them in terms of more
fundamental design patterns.</xhtml:p>
<xhtml:p>Also, this article is littered with links. Click them. Read
them. Digest them. Read the books they reference. Design and
architectural patterns exist because developers observed the
patterns and gave them names; learn to recognize them and apply
them, at all levels of your application.</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[A Better $state.reload for the AngularJS UI-Router]]></title>
    <published>2014-05-08T17:00:00+0000</published>
    <updated>2014-05-08T17:00:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2014-05-08-angular-ui-router-reload.html"/>
    <id>http://mwop.net/blog/2014-05-08-angular-ui-router-reload.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>While working on <xhtml:a href="http://apigility.org/">Apigility</xhtml:a>,
several times I ran into an odd issue: after fetching new data via
an API and assigning it to a scoped variable, content would flash
into existence... and then disappear. Nothing would cause it to
display again other than a browser reload of the page.</xhtml:p>
<xhtml:h2>Setup</xhtml:h2>
<xhtml:p>I have a page that lists a set of items. When you create an
item, you push data to the API, and, when done, the new item should
be in that list.</xhtml:p>
<xhtml:h2>First try: append to list</xhtml:h2>
<xhtml:p>My first attempt was just appending the data to the list.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
service.create(data).then(function (newItem) {
    flash.success = 'Successfully created something';
    /* append new item to list */
    $scope.services.push(newItem);
});
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>This worked... until you left that screen and returned. At that
point, the new item would be gone, even if I coded my ui-router
states to force a cache refresh.</xhtml:p>
<xhtml:h2>Refresh list</xhtml:h2>
<xhtml:p>My next attempt was to write a routine that would do a cache
refresh after creating the new item.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
service.create(data).then(function (newItem) {
    flash.success = 'Successfully created something';
    service.fetchAll(var force = true).then(function (services) {
        $scope.services = services;
    });
});
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>This is when I started noticing the "flash of content" problem.
Essentially, immediately after fetching the set of services, you'd
see the new item appended... and then it would disappear.</xhtml:p>
<xhtml:h2>$state.reload()</xhtml:h2>
<xhtml:p>At this point, I figured I'd use the ui-router to force a
refresh, specifically via <xhtml:code>$state.reload()</xhtml:code>.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
service.create(data).then(function (newItem) {
    flash.success = 'Successfully created something';
    service.fetchAll(var force = true).then(function (services) {
        $scope.services = services;
        $state.reload();
    });
});
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>I tried both with and without setting the scoped variable.
Initially, I thought it was working -- but, as it turned out, I
missed a case. I tested every single time with at least one item
already in the list -- and this approach worked. However, when I
tried with the list not yet populated, failure once again.</xhtml:p>
<xhtml:h2>Success: $timeout</xhtml:h2>
<xhtml:p>Surprisingly, the least intuitive solution ended up working:
introducing a delay.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
service.create(data).then(function (newItem) {
    flash.success = 'Successfully created something';
    service.fetchAll(var force = true)
        .then(function (services) {
            $scope.services = services;
        }).then(function () {
            return $timeout(function () {
                $state.go('.', {}, { reload: true });
            }, 100);
        });
});
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>I have a few things to note about this. First, I moved the
"reload" into its own promise. This was done to ensure it doesn't
block on the scope assignment. Second, I introduce a
<xhtml:code>$timeout</xhtml:code> call. This essentially gives the scope a
chance to populate before the reload triggers. Some examples I saw
did a 1ms timeout; I found in practice that this was not long
enough; 100ms was long enough, and did not introduce a noticeable
delay in UI responsiveness. Finally, you'll note this does not use
<xhtml:code>$state.reload()</xhtml:code>. This is due to discovering that part
of my problem is a <xhtml:a href="https://github.com/angular-ui/ui-router/issues/582">known bug in
<xhtml:code>$state.reload()</xhtml:code></xhtml:a>, whereby state "resolve"
configuration is not honored.</xhtml:p>
<xhtml:p>I hope this approach helps others -- I've found it to be robust
and predictable.</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Apigility: Using RPC with HAL]]></title>
    <published>2014-03-26T20:30:00+0000</published>
    <updated>2014-03-26T20:30:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2014-03-26-apigility-rpc-with-hal.html"/>
    <id>http://mwop.net/blog/2014-03-26-apigility-rpc-with-hal.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>A few days ago, we <xhtml:a href="http://bit.ly/ag-1-beta1">released
our first beta of Apigility</xhtml:a>. We've started our documentation
effort now, and one question has arisen a few times that I want to
address: How can you use Hypermedia Application Language (HAL) in
RPC services?</xhtml:p>
<xhtml:h2>HAL?</xhtml:h2>
<xhtml:p><xhtml:a href="http://tools.ietf.org/html/draft-kelly-json-hal-06">Hypermedia
Application Language</xhtml:a> is an IETF proposal for how to represent
resources and their relations within APIs. Technically, it provides
two mediatypes, <xhtml:code>application/hal+json</xhtml:code> and
<xhtml:code>application/hal+xml</xhtml:code>; however, Apigility only provides
the JSON variant.</xhtml:p>
<xhtml:p>The important things to know about HAL are:</xhtml:p>
<xhtml:ul>
<xhtml:li>
<xhtml:p>It provides a standard way of describing relational links. All
relational links are under a <xhtml:code>_links</xhtml:code> property of the
resource. That property is an object. Each property of that object
is a link relation; the value of each link relation is an object
(or array of such objects) describing the link that must minimally
contain an <xhtml:code>href</xhtml:code> proerty. The link object itself can
contain some additional metadata, such as a mediatype, a name
(useful for differentiating between multiple link objects assigned
to the same relation).</xhtml:p>
<xhtml:p>While not required, the specification recommends resources
contain a "self" relational link, indicating the canonical location
for the resource. This is particularly useful when we consider
embedding (the next topic).</xhtml:p>
<xhtml:p>Sound hard? It's not:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {
            "href": "/blog/2014-03-26-apigility-rpc-with-hal"
        }
    }
}
        </xhtml:code>
</xhtml:pre></xhtml:div>
</xhtml:li>
<xhtml:li>
<xhtml:p>Besides link relations, HAL also provides a standard way of
describing <xhtml:em>embedded resources</xhtml:em>. An embedded resource is any
other resource you can address via your API, and, as such, would be
structured as a HAL resource -- in other words, it would have a
<xhtml:code>_links</xhtml:code> property with relational links. Essentially,
any property of the resource you're returning that can itself be
addressed via the URI must be <xhtml:em>embedded</xhtml:em> in the resource.
This is done via the property <xhtml:code>_embedded</xhtml:code>.</xhtml:p>
<xhtml:p>Like <xhtml:code>_links</xhtml:code>, <xhtml:code>_embedded</xhtml:code> is an object.
Each key in the object is the local name by which the resource
refers to the embedded resource. The value of such keys can either
be HAL resources or <xhtml:em>arrays</xhtml:em> of HAL resources; in fact, this
is how <xhtml:em>collections</xhtml:em> are represented in HAL!</xhtml:p>
<xhtml:p>As examples:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {
            "href": "/blog/2014-03-26-apigility-rpc-with-hal"
        }
    },
    "_embedded": {
        "author": {
            "_links": {
                "self": {
                    "href": "/blog/author/matthew"
                }
            },
            "id": "matthew",
            "name": "Matthew Weier O'Phinney",
            "url": "http://mwop.net"
        },
        "tags": [
            {
                "_links": {
                    "self": {
                        "href": "/blog/tag/php"
                    }
                },
                "id": "php"
            },
            {
                "_links": {
                    "self": {
                        "href": "/blog/tag/rest"
                    }
                },
                "id": "rest"
            }
        ]
    }
}
        </xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The example above shows two embedded resources. The first is the
author; the second, a collection of tags. Note that <xhtml:em>every</xhtml:em>
object under <xhtml:code>_embedded</xhtml:code> is a HAL object!</xhtml:p>
<xhtml:p>You can go quite far with this -- you can also have embedded
resources inside your embedded resources, arbitrarily deep.</xhtml:p>
</xhtml:li>
</xhtml:ul>
<xhtml:h2>RPC?</xhtml:h2>
<xhtml:p>RPC stands for Remote Procedure Call, and, when describing a web
API, is usually used to describe a web service that publishes
multiple method calls at a single URI using only <xhtml:code>POST</xhtml:code>;
XML-RPC and SOAP are the usual suspects.</xhtml:p>
<xhtml:p>In Apigility, we use the term RPC in a much looser sense; we use
it to describe one-off services: actions like "authenticate," or
"notify," or "register" would all make sense here. They are actions
that usually only need to respond to a single HTTP method, and
which may or may not describe a "thing", which is what we usually
consider a "resource" when discussing REST terminology.</xhtml:p>
<xhtml:p>That said: what if what we want to return from the RPC call
<xhtml:em>are</xhtml:em> REST resources?</xhtml:p>
<xhtml:h2>Returning HAL from RPC Services</xhtml:h2>
<xhtml:p>In order to return HAL from RPC services, we need to understand
(a) how Content Negotiation works, and (b) what needs to be
returned in order for the HAL renderer to be able to create a
representation.</xhtml:p>
<xhtml:p>For purposes of this example, I'm positing a
<xhtml:code>RegisterController</xhtml:code> as an RPC service that, on success,
is returning a <xhtml:code>User</xhtml:code> object that I want rendered as a
HAL resource.</xhtml:p>
<xhtml:p>The <xhtml:a href="https://github.com/zfcampus/zf-content-negotiation">zf-content-negotiation</xhtml:a>
module takes care of content negotiation for Apigility. It
introspects the <xhtml:code>Accept</xhtml:code> header in order to determine if
we can return a representation, and then, if it can, will cast any
<xhtml:code>ZF\ContentNegotiation\ViewModel</xhtml:code> returned from a
controller to the appropriate view model for the representation.
From there, a renderer will pick up the view model and do what
needs to be done.</xhtml:p>
<xhtml:p>So, the first thing we have to do is return
<xhtml:code>ZF\ContentNegotiation\ViewModel</xhtml:code> instances from our
controller.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
use Zend\Mvc\Controller\AbstractActionController;
use ZF\ContentNegotiation\ViewModel;

class RegisterController extends AbstractActionController
{
    public function registerAction()
    {
        /* ... do some work ... get a user ... */
        return new ViewModel(array('user' =&gt; $user));
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The <xhtml:a href="https://github.com/zfcampus/zf-hal">zf-hal</xhtml:a>
module in Apigility creates the actual HAL representations.
<xhtml:code>zf-hal</xhtml:code> looks for a "payload" variable in the view
model, and expects that value to be either a
<xhtml:code>ZF\Hal\Entity</xhtml:code> (single item) or
<xhtml:code>ZF\Hal\Collection</xhtml:code>. When creating an
<xhtml:code>Entity</xhtml:code> object, you need the object being represented,
as well as the identifier. So, let's update our return value.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
use Zend\Mvc\Controller\AbstractActionController;
use ZF\ContentNegotiation\ViewModel;
use ZF\Hal\Entity;

class RegisterController extends AbstractActionController
{
    public function registerAction()
    {
        /* ... do some work
         * ... get a $user
         * ... assume we have also now have an $id
         */
        return new ViewModel(array('payload' =&gt; array(
            'user' =&gt; new Entity($user, $id),
        )));
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p><xhtml:code>zf-hal</xhtml:code> contains what's called a "metadata map".
This is a map of classes to information on how <xhtml:code>zf-hal</xhtml:code>
should render them: what route to use, what additional relational
links to inject, how to serialize the object, what field represents
the identifier, etc.</xhtml:p>
<xhtml:p>In most cases, you will have likely already defined a REST
service for the resource you want to return from the RPC service,
in which case you will be done. However, if you want, you can go in
and manually configure the metadata map in your API module's
<xhtml:code>config/module.config.php</xhtml:code> file:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
return array(
    /* ... */
    'zf-hal' =&gt; array(
        'metadata_map' =&gt; array(
            'User' =&gt; array(
                'route_name' =&gt; 'api.rest.user',
                'entity_identifier_name' =&gt; 'username',
                'route_identifier_name' =&gt; 'user_id',
                'hydrator' =&gt; 'Zend\Stdlib\Hydrator\ObjectProperty',
            ),
        ),
    ),
);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Finally, we need to make sure that the service is configured to
actually return HAL. We can do this in the admin if we want. Find
the "Content Negotiation" section of the admin, and the "Content
Negotiation Selector" item, and set that to "HalJson"; don't forget
to save! Alternately, you can do this manually in the API module's
<xhtml:code>config/module.config.php</xhtml:code> file, under the
<xhtml:code>zf-content-negotiation</xhtml:code> section:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
return array(
    /* ... */
    'zf-content-negotiation' =&gt; array(
        'controllers' =&gt; array(
            /* ... */
            'RegisterController' =&gt; 'HalJson',
        ),
        /* ... */
    ),
);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Once your changes are complete, when you make a successful
request to the URI for your "register" RPC service, you'll receive
a HAL response pointing to the canonical URI for the user resource
created!</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[A Bower Primer]]></title>
    <published>2013-12-03T15:50:00+0000</published>
    <updated>2013-12-03T15:50:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2013-12-03-bower-primer.html"/>
    <id>http://mwop.net/blog/2013-12-03-bower-primer.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>Recently, I've been doing a fair bit of frontend development
with my team as we've worked on the <xhtml:a href="http://apigility.org/">Apigility</xhtml:a> admin. This has meant working
with a variety of both JavaScript and CSS libraries, often trying
something out only to toss it out again later. Working with
frontend libraries has been quite a hassle, due to a combination of
discovery, installation issues, and build issues (minimization,
primarily). I figured there must a better way.</xhtml:p>
<xhtml:h2>Background</xhtml:h2>
<xhtml:p>Until recently, discovery of JS and CSS libraries has gone
something like this:</xhtml:p>
<xhtml:ol>
<xhtml:li>Search for functionality via Google</xhtml:li>
<xhtml:li>Generally find a solution on StackOverflow</xhtml:li>
<xhtml:li>Discover said solution relies on a third-party library</xhtml:li>
<xhtml:li>Google for said library</xhtml:li>
<xhtml:li>Generally find said library on GitHub</xhtml:li>
<xhtml:li>Clone the library locally</xhtml:li>
<xhtml:li>Either build the final assets, or try and locate them in the
repo</xhtml:li>
<xhtml:li>Minimize the assets</xhtml:li>
<xhtml:li>Copy the assets into the project</xhtml:li>
</xhtml:ol>
<xhtml:p>Frontend development sucks.</xhtml:p>
<xhtml:p>Then I started noticing these files called <xhtml:code>.bowerrc</xhtml:code>
and <xhtml:code>bower.json</xhtml:code> in many of the aforementioned
libraries, and also that <xhtml:a href="http://ralphschindler.com/">Ralph</xhtml:a> had put some inside our
Apigility skeleton. I got curious as to what this "bower" might
be.</xhtml:p>
<xhtml:h2>Bower: Package management for the web</xhtml:h2>
<xhtml:p>Essentially, <xhtml:a href="http://bower.io/">Bower</xhtml:a> is, to use the
project's words, "a package manager for the web." Written in
JavaScript, and running on <xhtml:a href="http://nodejs.org/">node.js</xhtml:a>, it is to frontend assets what
<xhtml:a href="https://npmjs.org/">npm</xhtml:a> is to node, or <xhtml:a href="https://getcomposer.org">Composer</xhtml:a> is to PHP. It allows you to
define what assets you need in your application, including the
versions, and then install them. If any of those assets have other
dependencies, those, too, will be installed.</xhtml:p>
<xhtml:p>Later, you can update the dependencies, add or remove
dependencies, and more.</xhtml:p>
<xhtml:p>On top of that, bower allows you to <xhtml:em>search</xhtml:em> for
packages, which essentially allows you to eliminate most of the
steps 4 and on in my list above.</xhtml:p>
<xhtml:h2>A Bower Primer</xhtml:h2>
<xhtml:p>So, how do you use bower?</xhtml:p>
<xhtml:p>In my experience, which is not extensive by any stretch, the
usage is like this:</xhtml:p>
<xhtml:ol>
<xhtml:li>Search for functionality via Google</xhtml:li>
<xhtml:li>Generally find a solution on StackOverflow</xhtml:li>
<xhtml:li>Discover said solution relies on a third-party library</xhtml:li>
<xhtml:li>Use bower to search for said library</xhtml:li>
<xhtml:li>Add the discovered library to your <xhtml:code>bower.json</xhtml:code>
file</xhtml:li>
<xhtml:li>Run <xhtml:code>bower install</xhtml:code> or <xhtml:code>bower
update</xhtml:code></xhtml:li>
</xhtml:ol>
<xhtml:p>I've found that most projects registered with bower have
minimized builds available (as well as the full source build),
which is a huge boon in terms of performance. It also eliminates
the "minimize the assets" step from my original list.</xhtml:p>
<xhtml:p>To use bower, you'll need two files. The first is
<xhtml:code>.bowerrc</xhtml:code> which goes in your project root; you'll run
<xhtml:code>bower</xhtml:code> from this same directory. This file tells bower
how to run, and where to install things, and, despite being an RC
file, is written in JSON. Mine usually looks like this:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "directory": "public/assets/vendor"
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The above tells bower to install dependencies in the
<xhtml:code>public/assets/vendor</xhtml:code> subdirectory.</xhtml:p>
<xhtml:p>The second file you need is <xhtml:code>bower.json</xhtml:code>. This file
tells bower what asset packages you want to install, and the
preferred version. (The file can also be used to define a package,
just like with Composer or npm.) As an example, the following is a
definition I used for an Apigility example:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "name": "ag-contacts-demo",
    "version": "0.0.1",
    "ignore": [
        "**/.*"
    ],
    "dependencies": {
        "angular": "~1.2",
        "angular-resource": "~1.2",
        "angular-route": "~1.2",
        "bootstrap": "&gt;=3.0.0",
        "font-awesome": "~3.2.1"
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Bower requires that packages use <xhtml:a href="http://semver.org/">Semantic Versioning</xhtml:a>. You can specify exact
versions, minor versions, or major versions, combine them with
comparison operators (<xhtml:code>&lt;</xhtml:code>, <xhtml:code>&gt;</xhtml:code>,
<xhtml:code>=</xhtml:code>, etc.), or use the "next significant release"
operator ("~") to indicate a given version up to the next more
general release (e.g., "~1.2" is equivalent to
"&gt;=1.2,&lt;2.0").</xhtml:p>
<xhtml:p>Once you have these defined, you should also add an entry to
your <xhtml:code>.gitignore</xhtml:code> file to exclude the directory you list
in your <xhtml:code>.bowerrc</xhtml:code>; these files can be installed at
build time, and thus help you keep your project repository lean.
Per the above example:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="text">
public/assets/vendor/
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>At this point, run <xhtml:code>bower install</xhtml:code>, and bower will
resolve all dependencies and install them where you want.</xhtml:p>
<xhtml:p>At any point, you can list what packages bower has installed, as
well as the versions it has installed. The <xhtml:code>bower help</xhtml:code>
command is your friend should those needs arise.</xhtml:p>
<xhtml:h2>Closing Thoughts</xhtml:h2>
<xhtml:p>I'm quite happy with the various tools emerging to make modern
web development easier by allowing developers to more easily share
their work, as well as ensure that all dependencies are easily
installable. Bower is another tool in my arsenal as a web
developer, giving me a consistent set of dependency management
tools from my server-side development all the way to my client-side
application.</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[RESTful APIs with ZF2, Part 3]]></title>
    <published>2013-02-25T12:29:00+0000</published>
    <updated>2013-02-25T12:29:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2013-02-25-restful-apis-with-zf2-part-3.html"/>
    <id>http://mwop.net/blog/2013-02-25-restful-apis-with-zf2-part-3.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>In my <xhtml:a href="/blog/2013-02-11-restful-apis-with-zf2-part-1.html">previous</xhtml:a>
<xhtml:a href="/blog/2013-02-13-restful-apis-with-zf2-part-2.html">posts</xhtml:a>, I
covered basics of JSON hypermedia APIs using Hypermedia Application
Language (HAL), and methods for reporting errors, including
API-Problem and vnd.error.</xhtml:p>
<xhtml:p>In this post, I'll be covering <xhtml:em>documenting</xhtml:em> your API --
techniques you can use to indicate what HTTP operations are
allowed, as well as convey the full documentation on what endpoints
are available, what they accept, and what you can expect them to
return.</xhtml:p>
<xhtml:p>While I will continue covering general aspects of RESTful APIs
in this post, I will also finally introduce several ZF2-specific
techniques.</xhtml:p>
<xhtml:h2>Why Document?</xhtml:h2>
<xhtml:p>If you're asking this question, you've either never consumed
software, or your software is perfect and self-documenting. I
frankly don't believe either one.</xhtml:p>
<xhtml:p>In the case of APIs, those consuming the API need to know how to
use it.</xhtml:p>
<xhtml:ul>
<xhtml:li>What endpoints are available? Which operations are available
for each endpoint?</xhtml:li>
<xhtml:li>What does each endpoint expect as a payload during the
request?</xhtml:li>
<xhtml:li>What can you expect as a payload in return?</xhtml:li>
<xhtml:li>How will errors be communicated?</xhtml:li>
</xhtml:ul>
<xhtml:p>While the promise of hypermedia APIs is that each response tells
you the next steps available, you still, somewhere along the way,
need more information - what payloads look like, which HTTP verbs
should be used, and more. If you're <xhtml:strong>not</xhtml:strong>
documenting your API, you're "doing it wrong."</xhtml:p>
<xhtml:h2>Where Should Documentation Live?</xhtml:h2>
<xhtml:p>This is the much bigger question.</xhtml:p>
<xhtml:p>Of the questions I raised above, detailing what should be
documented, there are two specific types. When discussing what
operations are available, we have a technical solution in the form
of the <xhtml:code>OPTIONS</xhtml:code> method and its counterpart, the
<xhtml:code>Allow</xhtml:code> header. Everything else falls under end-user
documentation.</xhtml:p>
<xhtml:h2>OPTIONS</xhtml:h2>
<xhtml:p>The HTTP specification details the <xhtml:code>OPTIONS</xhtml:code> method
as idempotent, non-cacheable, and for use in detailing what
operations are available for the given resource specified by the
request URI. It makes specific mention of the <xhtml:code>Allow</xhtml:code>
header, but does not limit what is returned for requests made via
this method.</xhtml:p>
<xhtml:p>The <xhtml:code>Allow</xhtml:code> header details the allowed HTTP methods
for the given resource.</xhtml:p>
<xhtml:p>Used in combination, you make an <xhtml:code>OPTIONS</xhtml:code> request to
a URI, and it should return a response containing an
<xhtml:code>Allow</xhtml:code> header; from that header value, you then know
what other HTTP methods can be made to that URI.</xhtml:p>
<xhtml:p>What this tells us is that our RESTful endpoint should do the
following:</xhtml:p>
<xhtml:ul>
<xhtml:li>When an <xhtml:code>OPTIONS</xhtml:code> request is made, return a response
with an <xhtml:code>Allow</xhtml:code> header that has a list of the available
HTTP methods allowed.</xhtml:li>
<xhtml:li>For any HTTP method we do <xhtml:em>not</xhtml:em> allow, we should return
a "405 Not Allowed" response.</xhtml:li>
</xhtml:ul>
<xhtml:p>These are fairly easy to accomplish in ZF2. <xhtml:em>(See? I promised
I'd get to some ZF2 code in this post!)</xhtml:em></xhtml:p>
<xhtml:p>When creating RESTful endpoints in ZF2, I recommend using
<xhtml:code>Zend\Mvc\Controller\AbstractRestfulController</xhtml:code>. This
controller contains an <xhtml:code>options()</xhtml:code> method which you can
use to respond to an <xhtml:code>OPTIONS</xhtml:code> request. As with any ZF2
controller, returning a response object will prevent rendering and
bubble out immediately so that the response is returned.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
namespace My\Controller;
use Zend\Mvc\Controller\AbstractRestfulController;

class FooController extends AbstractRestfulController
{
    public function options()
    {
        $response = $this-&gt;getResponse();
        $headers  = $response-&gt;getHeaders();

        // If you want to vary based on whether this is a collection or an
        // individual item in that collection, check if an identifier from
        // the route is present
        if ($this-&gt;params()-&gt;fromRoute('id', false)) {
            // Allow viewing, partial updating, replacement, and deletion
            // on individual items
            $headers-&gt;addHeaderLine('Allow', implode(',', array(
                'GET',
                'PATCH',
                'PUT',
                'DELETE',
            )));
            return $response;
        }

        // Allow only retrieval and creation on collections
        $headers-&gt;addHeaderLine('Allow', implode(',', array(
            'GET',
            'POST',
        )));
        return $response;
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The next trick is returning the 405 response if an invalid
option is used. For this, you can create a listener in your
controller, and wire it to listen at higher-than-default priority.
As an example:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
namespace My\Controller;
use Zend\EventManager\EventManagerInterface;
use Zend\Mvc\Controller\AbstractRestfulController;

class FooController extends AbstractRestfulController
{
    protected $allowedCollectionMethods = array(
        'GET',
        'POST',
    );

    protected $allowedResourceMethods = array(
        'GET',
        'PATCH',
        'PUT',
        'DELETE',
    );

    public function setEventManager(EventManagerInterface $events)
    {
        parent::setEventManager($events);
        $events-&gt;attach('dispatch', array($this, 'checkOptions'), 10);
    }

    public function checkOptions($e)
    {
        $matches  = $e-&gt;getRouteMatch();
        $response = $e-&gt;getResponse();
        $request  = $e-&gt;getRequest();
        $method   = $request-&gt;getMethod();

        // test if we matched an individual resource, and then test
        // if we allow the particular request method
        if ($matches-&gt;getParam('id', false)) {
            if (!in_array($method, $this-&gt;allowedResourceMethods)) {
                $response-&gt;setStatusCode(405);
                return $response;
            }
            return;
        }

        // We matched a collection; test if we allow the particular request 
        // method
        if (!in_array($method, $this-&gt;allowedCollectionMethods)) {
            $response-&gt;setStatusCode(405);
            return $response;
        }
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Note that I moved the allowed methods into properties; if I did
the above, I'd refactor the <xhtml:code>options()</xhtml:code> method to use
those properties as well to ensure they are kept in sync.</xhtml:p>
<xhtml:p>Also note that in the case of an invalid method, I return a
response object. This ensures that nothing else needs to execute in
the controller; I discover the problem and return early.</xhtml:p>
<xhtml:h2>End-User Documentation</xhtml:h2>
<xhtml:p>Now that we have the technical solution out of the way, we're
still left with the bulk of the work left to accomplish: providing
end-user documentation detailing the various payloads, errors,
etc.</xhtml:p>
<xhtml:p>I've seen two compelling approaches to this problem. The first
builds on the <xhtml:code>OPTIONS</xhtml:code> method, and the other uses a
hypermedia link in every response to point to documentation.</xhtml:p>
<xhtml:p>The <xhtml:code>OPTIONS</xhtml:code> solution is this: <xhtml:a href="http://zacstewart.com/2012/04/14/http-options-method.html">use the
body of an <xhtml:code>OPTIONS</xhtml:code> response to provide
documentation</xhtml:a>. (Keith Casey <xhtml:a href="http://vimeo.com/49613738">gave an excellent short presentation
about this at REST Fest 2012</xhtml:a>).</xhtml:p>
<xhtml:p>The <xhtml:code>OPTIONS</xhtml:code> method allows for you to return a body
in the response, and also allows for content negotiation. The
theory, then, is that you return media-type-specific documentation
that details the methods allowed, and what they specifically accept
in the body. While there is no standard for this at this time, the
first article I linked suggested including a description, the
parameters expected, and one or more example request bodies for
each HTTP method allowed; you'd likely also want to detail the
responses that can be expected.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "POST": {
        "description": "Create a new status",
        "parameters": {
            "type": {
                "type": "string",
                "description": "Status type -- text, image, or url; defaults to text",
                "required": false
            },
            "text": {
                "type": "string",
                "description": "Status text; required for text types, optional for others",
                "required": false
            },
            "image_url": {
                "type": "string",
                "description": "URL of image for image types; required for image types",
                "required": false
            },
            "link_url": {
                "type": "string",
                "description": "URL of image for link types; required for link types",
                "required": false
            }
        },
        "responses": [
            {
                "describedBy": "http://example.com/problems/invalid-status",
                "title": "Submitted status was invalid",
                "detail": "Missing text field required for text type"
            },
            {
                "id": "abcdef123456",
                "type": "text",
                "text": "This is a status update",
                "timestamp": "2013-02-22T10:06:05+0:00"
            }
        ],
        "examples": [
            {
                "text": "This is a status update"
            },
            {
                "type": "image",
                "text": "This is the image caption",
                "image_url": "http://example.com/favicon.ico"
            },
            {
                "type": "link",
                "text": "This is a description of the link",
                "link_url": "http://example.com/"
            },
        ]
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>If you were to use this methodology, you would alter the
<xhtml:code>options()</xhtml:code> method such that it does not return a
response object, but instead return a view model with the
documentation.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
namespace My\Controller;
use Zend\Mvc\Controller\AbstractRestfulController;

class FooController extends AbstractRestfulController
{
    protected $viewModelMap = array(/* ... */);

    public function options()
    {
        $response = $this-&gt;getResponse();
        $headers  = $response-&gt;getHeaders();

        // Get a view model based on Accept types
        $model    = $this-&gt;acceptableViewModelSelector($this-&gt;viewModelMap);

        // If you want to vary based on whether this is a collection or an
        // individual item in that collection, check if an identifier from
        // the route is present
        if ($this-&gt;params()-&gt;fromRoute('id', false)) {
            // Still set the Allow header
            $headers-&gt;addHeaderLine('Allow', implode(
                ',', 
                $this-&gt;allowedResourceMethods
            ));

            // Set documentation specification as variables
            $model-&gt;setVariables($this-&gt;getResourceDocumentationSpec());
            return $model;
        }

        // Allow only retrieval and creation on collections
        $headers-&gt;addHeaderLine('Allow', implode(
            ',',
            $this-&gt;allowedCollectionMethods
        ));
        $model-&gt;setVariables($this-&gt;getCollectionDocumentationSpec());
        return $model;
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>I purposely didn't provide the implementations of the
<xhtml:code>getResourceDocumentationSpec()</xhtml:code> and
<xhtml:code>getCollectionDocumentationSpec()</xhtml:code> methods, as that will
likely be highly specific to your application. Another possibility
is to use your view engine for this, and specify a template file
that has the fully-populated information. This would require a
custom renderer when using JSON or XML, but is a pretty easy
solution.</xhtml:p>
<xhtml:p><xhtml:strong>However, there's one cautionary tale to tell</xhtml:strong>,
something I already mentioned: <xhtml:code>OPTIONS</xhtml:code>, per the
specification, is <xhtml:em>non-cacheable</xhtml:em>. What this means is that
everytime somebody makes an <xhtml:code>OPTIONS</xhtml:code> request, any cache
control headers you provide will be ignored, which means hitting
the server for each and every request to the documentation.
Considering documentation is static, this is problematic; it has
even prompted <xhtml:a href="http://www.mnot.net/blog/2012/10/29/NO_OPTIONS">blog posts urging
you not to use OPTIONS for documentation</xhtml:a>.</xhtml:p>
<xhtml:p>Which brings us to the second solution for end-user
documentation: a static page referenced via a hypermedia link.</xhtml:p>
<xhtml:p>This solution is insanely easy: you simply provide a
<xhtml:code>Link</xhtml:code> header in your response, and provide a
<xhtml:code>describedby</xhtml:code> reference pointing to the documentation
page:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
Link: &lt;http://example.com/api/documentation.md&gt;; rel="describedby"
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>With ZF2, this is trivially easy to accomplish: create a route
and endpoint for your documentation, and then a listener on your
controller that adds the <xhtml:code>Link</xhtml:code> header to your
response.</xhtml:p>
<xhtml:p>The latter, adding the link header, might look like this:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
namespace My\Controller;
use Zend\EventManager\EventManagerInterface;
use Zend\Mvc\Controller\AbstractRestfulController;

class FooController extends AbstractRestfulController
{
    public function setEventManager(EventManagerInterface $events)
    {
        parent::setEventManager($events);
        $events-&gt;attach('dispatch', array($this, 'injectLinkHeader'), 20);
    }

    public function injectLinkHeader($e)
    {
        $response = $e-&gt;getResponse();
        $headers  = $response-&gt;getHeaders();
        $headers-&gt;addHeaderLine('Link', sprintf(
            '</xhtml:code>
</xhtml:pre></xhtml:div>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[RESTful APIs with ZF2, Part 2]]></title>
    <published>2013-02-13T13:40:00+0000</published>
    <updated>2013-02-13T13:40:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2013-02-13-restful-apis-with-zf2-part-2.html"/>
    <id>http://mwop.net/blog/2013-02-13-restful-apis-with-zf2-part-2.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>In my <xhtml:a href="/blog/2013-02-11-restful-apis-with-zf2-part-1.html">last post</xhtml:a>,
I covered some background on REST and the Richardson Maturity
Model, and some emerging standards around hypermedia APIs in JSON;
in particular, I outlined aspects of Hypermedia Application
Language (HAL), and how it can be used to define a generic
structure for JSON resources.</xhtml:p>
<xhtml:p>In this post, I cover an aspect of RESTful APIs that's often
overlooked: reporting problems.</xhtml:p>
<xhtml:h2>Background</xhtml:h2>
<xhtml:p>APIs are useful when they're working. But when they fail,
they're only useful if they provide us with meaningful information;
if all I get is a status code, and no indication of what caused the
issue, or where I might look for more information, I get
frustrated.</xhtml:p>
<xhtml:p>In consuming APIs, I've come to the following conclusions:</xhtml:p>
<xhtml:ul>
<xhtml:li>Error conditions need to provide detailed information as to
what went wrong, and what steps I may be able to take next. An
error code with no context gives me nothing to go on.</xhtml:li>
<xhtml:li>Errors need to be reported consistently. Don't report the error
one way one time, and another way the next.</xhtml:li>
<xhtml:li><xhtml:strong>DO</xhtml:strong> use HTTP status codes to indicate an error
happened. Nothing is more irksome than getting back a 200 status
with an error payload.</xhtml:li>
<xhtml:li>Errors should be reported in a format I have indicated I will
Accept (as in the HTTP header). Perhaps the only think more irksome
than a 200 status code for an error is getting back an HTML page
when I expect JSON.</xhtml:li>
</xhtml:ul>
<xhtml:h2>Why Status Codes Aren't Enough</xhtml:h2>
<xhtml:p>Since REST leverages and builds on HTTP, an expedient solution
for reporting problems is to simply use <xhtml:a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">HTTP
status codes</xhtml:a>. These are well understood by web developers,
right?</xhtml:p>
<xhtml:p><xhtml:code>4xx</xhtml:code> error codes are errors made by the requestor,
and are actually fairly reasonable to use for reporting things such
as lack of authorization tokens, incomplete requests, unsupportable
operations, or non-supported media types.</xhtml:p>
<xhtml:p>But what happens when the error is on the server - because
something has gone wrong such as inability to reach your
persistence layer or credential storage? The <xhtml:code>5xx</xhtml:code>
series of status codes is sparse and wholly unsuited to reporting
errors of these types -- <xhtml:em>though you'll likely still want to use
a <xhtml:code>500</xhtml:code> status to report the failure</xhtml:em>. But what do
you present to the consumer so that they know whether or not to try
again, or what to report to you so that you can fix the issue?</xhtml:p>
<xhtml:p>A status code simply isn't enough information most of the time.
Yes, you want to define standard status codes so that your clients
can perform reasonable branching, but you also need a way to
communicate <xhtml:em>details</xhtml:em> to the end-user, so that they can log
the information for themselves, display information to their own
end-users, and/or report it back to you so you can do something to
resolve the situation.</xhtml:p>
<xhtml:h2>Custom Media Types</xhtml:h2>
<xhtml:p>The first step is to use a custom media type. Media types are
typically both a name as well as a structure -- and the latter is
what we're after when it comes to error reporting.</xhtml:p>
<xhtml:p>If we return a response using this media type, the client then
knows how to parse it, and can then process it, log it,
whatever.</xhtml:p>
<xhtml:p>Sure, you can make up your own format -- as long as you are
consistent in using it, and you document it. But personally, I
don't like inventing new formats when standard formats exist
already. Custom formats mean that custom clients are required for
working with the services; using a standard format can save effort
and time.</xhtml:p>
<xhtml:p>In the world of JSON, I've come across two error media types
that appear to be gaining traction:
<xhtml:code>application/api-problem+json</xhtml:code> and
<xhtml:code>application/vnd.error+json</xhtml:code></xhtml:p>
<xhtml:h3>API-Problem</xhtml:h3>
<xhtml:p>This particular media type is <xhtml:a href="http://tools.ietf.org/html/draft-nottingham-http-problem-02">via
the IETF</xhtml:a>. Like HAL, it provides formats in both JSON and XML,
making it a nice cross-platform choice.</xhtml:p>
<xhtml:p>As noted already, the media type is
<xhtml:code>application/api-problem+json</xhtml:code>. The representation is a
single resource, with the following properties:</xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:strong>describedBy</xhtml:strong>: a URL to a document describing
the error condition (required)</xhtml:li>
<xhtml:li><xhtml:strong>title</xhtml:strong>: a brief title for the error condition
(required)</xhtml:li>
<xhtml:li><xhtml:strong>httpStatus</xhtml:strong>: the HTTP status code for the
current request (optional)</xhtml:li>
<xhtml:li><xhtml:strong>detail</xhtml:strong>: error details specific to this request
(optional)</xhtml:li>
<xhtml:li><xhtml:strong>supportId</xhtml:strong>: a URL to the specific problem
occurrence (e.g., to a log message) (optional)</xhtml:li>
</xhtml:ul>
<xhtml:p>As an example:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
HTTP/1.1 500 Internal Error
Content-Type: application/api-problem+json

{
    "describedBy": "http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html",
    "detail": "Status failed validation",
    "httpStatus": 500,
    "title": "Internal Server Error"
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The specification allows a large amount of flexibility -- you
can have your own custom error types, so long as you have a
description of them to link to. You can provide as little or as
much detail as you want, and even decide what information to expose
based on environment.</xhtml:p>
<xhtml:p>I personally like to point to the HTTP status code definitions,
and then provide request-specific detail; I find this gives quick
and simple results that I can later shape as I add more detail to
my API. However, the specification definitely encourages you to
have unique error types with discrete URIs that describe them --
never a bad thing when creating APIs.</xhtml:p>
<xhtml:h3>vnd.error</xhtml:h3>
<xhtml:p>This is a <xhtml:a href="https://github.com/blongden/vnd.error">proposed media type</xhtml:a>
within the HAL community. Like HAL, it provides formats in both
JSON and XML, making it a nice cross-platform choice.</xhtml:p>
<xhtml:p>It differentiates from API-Problem in a few ways. First, it
allows, and even encourages, reporting collections of errors. If
you consider PHP exceptions and the fact that they support
"previous" exceptions, this is a powerful concept; you can report
the entire chain of errors that led to the response. Second, it
encourages pushing detail out of the web service; errors include a
"logRef" property that points to where the error detail lives. This
is probably better illustrated than explained.</xhtml:p>
<xhtml:p>The response payload is an array of objects. Each object has the
following members:</xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:strong>logRef</xhtml:strong>: a unique identifier for the specific
error which can then be used to identify the error within
server-side logs (required)</xhtml:li>
<xhtml:li><xhtml:strong>message</xhtml:strong>: the error message itself
(required)</xhtml:li>
<xhtml:li><xhtml:strong>_links</xhtml:strong>: HAL-compatible links. Typically,
"help", "describes", and/or "describedBy" relations will be defined
here.</xhtml:li>
</xhtml:ul>
<xhtml:p>As an example, let's consider the API-Problem example I had
earlier, and provide a vnd.error equivalent:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
HTTP/1.1 500 Internal Error
Content-Type: application/vnd.error+json

[
    {
        "logRef": "someSha1HashMostLikely",
        "message": "Status failed validation",
        "_links": {
            "describedBy": {"href": "http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html"}
        }
    }
]
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>vnd.error basically begs you to create custom error types, with
documentation end-points that detail the source of the error and
what you can do about it (this is true of API-Problem as well).</xhtml:p>
<xhtml:p>The requirement to include a log reference ("logRef") and have
it be unique can be a stumbling block to implementation, however,
as it requires effort for uniquely identifying requests, and
logging. However, both the identification and logging can be
automated.</xhtml:p>
<xhtml:h2>Summary</xhtml:h2>
<xhtml:p>Error reporting in APIs is as important as the normal resource
payloads themselves. Without good error reporting, when an API
raises errors, clients have difficulty understanding what they can
do next, and cannot provide you, the API provider, with information
that will allow you to debug on the server side.</xhtml:p>
<xhtml:p>As noted at the beginning of the article, if you follow the
rules below, you'll make consumers of your API happier and more
productive.</xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:strong>DO</xhtml:strong> use appropriate HTTP status codes to
indicate an error happened.</xhtml:li>
<xhtml:li>Report errors in a format I have indicated I will Accept (as in
the HTTP header).</xhtml:li>
<xhtml:li>Report errors consistently. Don't report the error one way one
time, and another way the next. Standardize on a specific
error-reporting media type . While you <xhtml:em>can</xhtml:em> create your own
error structure, I recommend using documented, accepted standards.
This will make clients more re-usable, and make many of your
decisions for you.</xhtml:li>
<xhtml:li>Provide detailed information as to what went wrong, and what
steps I may be able to take next. Provide documentation for each
type of error, and link to that documentation from your error
payloads.</xhtml:li>
</xhtml:ul>
<xhtml:p>Which brings me to...</xhtml:p>
<xhtml:h2>Next time</xhtml:h2>
<xhtml:p>I realize I still haven't covered anything specific to ZF2, but
I'll start next time, when I cover the next topic: documenting your
API. An undocumented API is a useless API, so it's good to start
baking documentation in immediately. I'll survey some of the
possibilities and how they can be implemented in ZF2 in the next
installment, and then we can get our hands dirty with actual API
development.</xhtml:p>
<xhtml:h3>Updates</xhtml:h3>
<xhtml:p><xhtml:em>Note: I'll update this post with links to the other posts in
the series as I publish them.</xhtml:em></xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:a href="/blog/2013-02-11-restful-apis-with-zf2-part-1.html">Part
1</xhtml:a></xhtml:li>
<xhtml:li><xhtml:a href="/blog/2013-02-25-restful-apis-with-zf2-part-3.html">Part
3</xhtml:a></xhtml:li>
</xhtml:ul>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[RESTful APIs with ZF2, Part 1]]></title>
    <published>2013-02-12T11:42:00+0000</published>
    <updated>2013-02-13T13:40:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2013-02-11-restful-apis-with-zf2-part-1.html"/>
    <id>http://mwop.net/blog/2013-02-11-restful-apis-with-zf2-part-1.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>RESTful APIs have been an interest of mine for a couple of
years, but due to <xhtml:a href="http://framework.zend.com/blog//zend-framework-2-0-0-stable-released.html">
circumstances</xhtml:a>, I've not had much chance to work with them in
any meaningful fashion until recently.</xhtml:p>
<xhtml:p><xhtml:a href="http://akrabat.com/">Rob Allen</xhtml:a> and I proposed a
workshop for <xhtml:a href="http://conference.phpbenelux.eu/2013/">PHP
Benelux 2013</xhtml:a> covering RESTful APIs with ZF2. When it was
accepted, it gave me the perfect opportunity to dive in and start
putting the various pieces together.</xhtml:p>
<xhtml:h2>Background</xhtml:h2>
<xhtml:p>I've attended any number of conference sessions on API design,
read countless articles, and engaged in quite a number of
conversations. Three facts keep cropping up:</xhtml:p>
<xhtml:ol>
<xhtml:li>JSON is fast becoming the preferred exchange format due to the
ease with which it de/serializes in almost every language.</xhtml:li>
<xhtml:li>The "holy grail" is <xhtml:a href="http://martinfowler.com/articles/richardsonMaturityModel.html">Richardson
Maturity Model</xhtml:a> Level 3.</xhtml:li>
<xhtml:li>It's really hard to achieve RMM level 3 with JSON.</xhtml:li>
</xhtml:ol>
<xhtml:h3>Richardson Maturity Model</xhtml:h3>
<xhtml:p>As a quick review, the Richardson Maturity Model has the
following 4 levels:</xhtml:p>
<xhtml:ul>
<xhtml:li>Level 0: "The swamp of POX." Basically, a service that uses TCP
for transport, primarily as a form of remote procedure call (RPC).
Typically, these are not really leveraging HTTP in any meaningful
fashion; most systems will use HTTP POST for all interactions.
Also, you will often have a single endpoint for all interactions,
regardless of whether or not they are strictly related. XML-RPC,
SOAP, and JSON-RPC fall under this category.</xhtml:li>
<xhtml:li>Level 1: "Resources." In these services, you start breaking the
service into multiple services, one per "resource," or, in object
oriented terms, per object. This means a distinct URL per object,
which means each has its own distinct identity on the web; this
often extends not only to the collection of objects, but to
individual objects under the collection as well (e.g., "/books" as
well as "/books/life-of-pi"). The service may still be RPC in
nature, however, and, at this level, often is still using a single
HTTP method for all interactions with the resource.</xhtml:li>
<xhtml:li>Level 2: "HTTP Verbs." At this level, we start using HTTP verbs
with our services in the way the HTTP specification intends. GET is
for safe operations, and should be cacheable; POST is used for
creation and/or updating; DELETE can be used to delete a resource;
etc. Rather than doing RPC style methods, we leverage HTTP,
occasionally passing additional parameters via the query string or
request body. Considerations such as HTTP caching and idempotence
are taken into account.</xhtml:li>
<xhtml:li>Level 3: "Hypermedia Controls." Building on the previous level,
our resource representations now also include <xhtml:em>links</xhtml:em>, which
indicate what we can <xhtml:em>do next</xhtml:em>. At this level, our API
becomes practically self-describing; given a single end-point, we
should be able to start crawling it, using the links in a
representation to lead us to the next actions.</xhtml:li>
</xhtml:ul>
<xhtml:p>When I first started playing with web services around a decade
ago, everything was stuck at Level 0 or Level 1 -- usually with
Level 1 users downgrading to Level 0 because Level 0 offerred
consistency and predictability if you chose to use a service type
that had a defined envelope format (such as XML-RPC or SOAP). (I
even wrote the XML-RPC server implementation for Zend Framework
because I got sick of writing one-off parsers/serializers for
custom XML web service implementations. When you're implementing
many services, predictability is a huge win.)</xhtml:p>
<xhtml:p>A few years ago, I started seeing a trend towards Level 2. Web
developers like the simplicity of using HTTP verbs, as they map
very well to <xhtml:a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</xhtml:a>
operations -- the bread and butter of web development. Couple this
concept with JSON, and it becomes trivially simple to both create a
web service, as well as consume it.</xhtml:p>
<xhtml:p><xhtml:em>I'd argue that the majority of web developers are quite
happy to be at Level 2 -- and have no problem staying there.
They're productive, and the concepts are easy -- both to understand
and to implement.</xhtml:em></xhtml:p>
<xhtml:p>Level 3, though, is where it becomes really interesting. The
idea that I can examine the represention <xhtml:em>alone</xhtml:em> in order to
understand what I can do next is very intriguing and
empowering.</xhtml:p>
<xhtml:h3>JSON and Hypermedia</xhtml:h3>
<xhtml:p>With XML, hypermedia basically comes for free. Add some
&lt;link&gt; elements to your representation, and you're done --
and don't forget the link <xhtml:code>rel</xhtml:code>ations!</xhtml:p>
<xhtml:p>JSON, however, is another story.</xhtml:p>
<xhtml:p>Where do the links go? <xhtml:em>There is no single, defined way to
represent a hyperlink in JSON.</xhtml:em></xhtml:p>
<xhtml:p>Fortunately, there are some emerging standards.</xhtml:p>
<xhtml:p>First is use of the <xhtml:a href="http://www.w3.org/wiki/LinkHeader">"Link" HTTP header</xhtml:a>. While
the page I linked shows only a single link in the header, you can
have multiple links separated by commas. GitHub uses this when
providing pagination links in their API. Critics will point out
that the HTTP headers are not technically part of the
representation, however; strict interpetations of REST and RMM
indicate that the hypermedia links should be part of the resource
representation. Regardless, having the links in the HTTP headers is
useful for pre-traversal of a service, as you can perform HEAD
requests only to discover possible actions and workflows.</xhtml:p>
<xhtml:p><xhtml:a href="http://amundsen.com/media-types/collection/format/">Collection+JSON</xhtml:a>
is interesting, as it describes the entire JSON envelope. My one
criticism is that it details too much; whenever I see a format that
dictates how to describe types, I think of XML-RPC or SOAP, and get
a little twitchy. It's definitely worth a look, though.</xhtml:p>
<xhtml:p>What's captured my attention of late, however, is <xhtml:a href="http://stateless.co/hal_specification.html">Hypertext Application
Language</xhtml:a>, or HAL for short. HAL has very few rules, but
succinctly describes both how to provide hypermedia in JSON as well
as how to represent embedded resources - the two things that most
need standardized structure in JSON. It does this while still
providing a generic media type, and also describing a mirror image
XML format!</xhtml:p>
<xhtml:h3>HAL Media Types</xhtml:h3>
<xhtml:p>HAL defines two generic media types:
<xhtml:code>application/hal+xml</xhtml:code> and
<xhtml:code>application/hal+json</xhtml:code>. You will use these as the
response Content-Type, as they describe the response
representation; the client can simply request
<xhtml:code>application/json</xhtml:code>, and the response format remains
compatible.</xhtml:p>
<xhtml:h3>HAL and Links</xhtml:h3>
<xhtml:p>HAL provides a very simple structure for JSON hypermedia links.
First, all resource representations must contain hypermedia links,
and all links are provided in a "_links" object:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Second, links are properties of this object. The property name
is the link relation, and the value is an object containing
minimally an "href" property.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status/1234"}
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>If a given relation can have multiple links, you provide instead
an array of objects:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status/1234"},
        "conversation": [
            {"href": "http://example.com/api/status/1237"},
            {"href": "http://example.com/api/status/1241"}
        ]
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Individual links can contain other attributes as desired -- I've
seen people include the relation again so that it's self-contained
in the link object, and it's not uncommon to include a title or
name.</xhtml:p>
<xhtml:h3>HAL and Resources</xhtml:h3>
<xhtml:p>HAL imposes no structure over resources other than requiring the
hypermedia links; even then, you typically do not include the
hypermedia links when making a request of the web service; the
hypermedia links are included only in the representations
<xhtml:em>returned</xhtml:em> by the service.</xhtml:p>
<xhtml:p>So, as an example, you would POST the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
POST /api/status
Host: example.com
Accept: application/json
Content-Type: application/json

{
    "status": "This is my awesome status update!",
    "user": "mwop"
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>And from that request, you'd receive the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
201 Created
Location: http://example.com/api/status/1347
Content-Type: application/hal+json

{
    "_links": {
        "self": {"href": "http://example.com/api/status/1347"}
    },
    "id": "1347",
    "timestamp": "2013-02-11 23:33:47",
    "status": "This is my awesome status update!",
    "user": "mwop"
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:h3>HAL and Embedded Resources</xhtml:h3>
<xhtml:p>The other important thing that HAL defines is how to
<xhtml:em>embed</xhtml:em> resources. Why is this important? If the resource
references other resources, you will want to be able to link to
them so you can perform operations on them, too.</xhtml:p>
<xhtml:p>Embedded resources are represented inside an "_embedded" object
of the representation, and, as resources, contain their own
"_links" object as well. Each resource you embed is assigned to a
property of that object, and if multiple objects of the same type
are returned, an array of resources is assigned. In fact, this
latter is how you represent <xhtml:em>collections</xhtml:em> in HAL.</xhtml:p>
<xhtml:p>Let's consider a simple example first. In previous code samples,
I have a "user" that's a string; let's make that an embedded
resource instead.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status/1347"}
    },
    "id": "1347",
    "timestamp": "2013-02-11 23:33:47",
    "status": "This is my awesome status update!",
    "_embedded": {
        "user": {
            "_links": {
                "self": {"href": "http://example.com/api/user/mwop"}
            }
            "id": "mwop",
            "name": "Matthew Weier O'Phinney",
            "url": "http://mwop.net"
        }
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>I've moved the "user" out of the representation, and into the
"_embedded" object -- because this is where you define embedded
resources. Note that the "user" is a standard HAL resource itself
-- containing hypermedia links.</xhtml:p>
<xhtml:p>Now let's look at a collection:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status"},
        "next": {"href": "http://example.com/api/status?page=2"},
        "last": {"href": "http://example.com/api/status?page=100"}
    },
    "count": 2973,
    "per_page": 30,
    "page": 1,
    "_embedded": {
        "status": [
            {
                "_links": {
                    "self": {"href": "http://example.com/api/status/1347"}
                },
                "id": "1347",
                "timestamp": "2013-02-11 23:33:47",
                "status": "This is my awesome status update!",
                "_embedded": {
                    "user": {
                        "_links": {
                            "self": {"href": "http://example.com/api/user/mwop"}
                        }
                        "id": "mwop",
                        "name": "Matthew Weier O'Phinney",
                        "url": "http://mwop.net"
                    }
                }
            }
            /* ... */
        ]
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Note that the "status" property is an array; semantically, all
resources under this key are of the same type. Also note that the
parent resource has some additional link relations -- these are
related to pagination, and allow a client to determine what the
next and last pages are (and, if we were midway into the
collection, previous and first pages). Since the collection is also
a resource, it has some interesting metadata -- how many resources
are in the collection, how many we represent per page, and what the
current page is.</xhtml:p>
<xhtml:p>Also note that you can nest resources -- simply include an
"_embedded" object inside an embedded resource, with additional
resources, as I've done with the "user" resource inside the status
resource shown here. It's turtles all the way down.</xhtml:p>
<xhtml:h2>Next Time</xhtml:h2>
<xhtml:p>The title of this post indicates I'll be talking about building
RESTful APIs with ZF2 -- but so far, I've not said anything about
ZF2.</xhtml:p>
<xhtml:p>I'll get there. But there's another detour to take: reporting
errors.</xhtml:p>
<xhtml:h3>Updates</xhtml:h3>
<xhtml:p><xhtml:em>Note: I'll update this post with links to the other posts in
the series as I publish them.</xhtml:em></xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:a href="/blog/2013-02-13-restful-apis-with-zf2-part-2.html">Part
2</xhtml:a></xhtml:li>
<xhtml:li><xhtml:a href="/blog/2013-02-25-restful-apis-with-zf2-part-3.html">Part
3</xhtml:a></xhtml:li>
</xhtml:ul>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[OpenShift, Cron, and Naked Domains]]></title>
    <published>2012-12-30T15:52:00+0000</published>
    <updated>2012-12-30T15:52:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-12-30-openshift-cron-and-naked-domains.html"/>
    <id>http://mwop.net/blog/2012-12-30-openshift-cron-and-naked-domains.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>As an experiment, I migrated my website over to <xhtml:a href="http://openshift.redhat.com">OpenShift</xhtml:a> yesterday. I've been
hosting a pastebin there already, and have found the service to be
both straightforward and flexible; it was time to put it to a more
thorough test.</xhtml:p>
<xhtml:p>In the process, I ran into a number of interesting issues, some
of which took quite some time to resolve; this post is both to help
inform other potential users of the service, as well as act as a
reminder to myself.</xhtml:p>
<xhtml:h2>Cron</xhtml:h2>
<xhtml:p>OpenShift offers a <xhtml:a href="http://en.wikipedia.org/wiki/Cron">Cron</xhtml:a> cartridge, which I was
excited to try out.<xhtml:sup><xhtml:a href="#f1">1</xhtml:a></xhtml:sup></xhtml:p>
<xhtml:p>The basics are quite easy. In your repository's
<xhtml:code>.openshift</xhtml:code> directory is a <xhtml:code>cron</xhtml:code>
subdirectory, further divided into <xhtml:code>minutely</xhtml:code>,
<xhtml:code>hourly</xhtml:code>, <xhtml:code>daily</xhtml:code>, <xhtml:code>weekly</xhtml:code>, and
<xhtml:code>monthly</xhtml:code> subdirectories. You drop a script you want to
run into one of these directories, and push your changes
upstream.</xhtml:p>
<xhtml:p>The problem is: what if I want a job to run at a specific time
daily? or on the quarter hour? or on a specific day of the
week?</xhtml:p>
<xhtml:p>As it turns out, you can manage all of the above, just not quite
as succinctly as you would in a normal crontab. Here, for example,
is a script that I run at 5AM daily; I placed it in the
<xhtml:code>hourly</xhtml:code> directory so that it can test more
frequently:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
#!/bin/bash
if [ `date +%H` == "05" ]
then
    (
        export PHP=/usr/local/zend/bin/php ;
        cd $OPENSHIFT_REPO_DIR ; 
        $PHP public/index.php phlycomic fetch all ; 
        $PHP public/index.php phlysimplepage cache clear --page=pages/comics 
    )
fi
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>And here's one that runs on the quarter-hour, placed in the
<xhtml:code>minutely</xhtml:code> directory:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
#!/bin/bash
MINUTES=`date +%M`

for i in "00" "15" "30" "45";do
    if [ "$MINUTES" == "$i" ];then
        (
            export PHP=/usr/local/zend/bin/php ;
            cd $OPENSHIFT_REPO_DIR ;
            $PHP public/index.php githubfeed fetch 
        )
    fi
done
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The point is that if you need more specificity, push the script
into the next more specific directory, and test against the time of
execution.</xhtml:p>
<xhtml:h2>Naked Domains</xhtml:h2>
<xhtml:p>Naked domains are domains without a preceding subdomain. In my
case, this means "mwop.net", vs. "www.mwop.net".</xhtml:p>
<xhtml:p>The problem that cloud hosting presents is that the IP address
on which you are hosted can change at any time, for a variety of
reasons. As such, you typically cannot use DNS A records to point
to your domain; the recommendation is to use a CNAME record that
points the domain to a "virtual" domain registered with your cloud
hosting provider.</xhtml:p>
<xhtml:p>However, most domain registrars and DNS providers do not let you
do this for a naked domain, particularly if you also have MX or
other records associated with that naked domain.</xhtml:p>
<xhtml:p>Some registrars will allow you to forward the A record to a
subdomain. I tried this, but had limited success; I personally
found that I ended up in an infinite loop situation when doing the
DNS lookup.</xhtml:p>
<xhtml:p>Another solution is to have a redirect in place for your naked
domain to the subdomain, which can then be a CNAME record.
Typically, this would require you have a web server under your
control with a fixed IP that then simply redirects to the
subdomain. Fortunately, there's an easier solution: <xhtml:a href="http://wwwizer.com/naked-domain-redirect">wwwizer</xhtml:a>. You simply
point your naked domain A record to the wwwizer IP address, and
they will do a redirect to your <xhtml:code>www</xhtml:code> subdomain.</xhtml:p>
<xhtml:p>I implemented wwwizer on my domain (which is why you'll see
"www.mwop.net" in your location bar), and it's been working
flawlessly since doing so.</xhtml:p>
<xhtml:h4>Private repositories</xhtml:h4>
<xhtml:p>I keep my critical site settings in a private repository, which
allows me to version them while keeping the credentials they hold
out of the public eye. This means, however, that I need to use
<xhtml:a href="https://help.github.com/articles/managing-deploy-keys">GitHub
deploy keys</xhtml:a> on my server in order to retrieve changes.</xhtml:p>
<xhtml:p>This was simple enough: I created an <xhtml:code>ssh</xhtml:code>
subdirectory in my <xhtml:code>$OPENSHIFT_DATA_DIR</xhtml:code> directory, and
generated a new SSH keypair.</xhtml:p>
<xhtml:p>The problem was telling SSH to <xhtml:em>use</xhtml:em> this key when
fetching changes.</xhtml:p>
<xhtml:p>The solution is to use a combination of <xhtml:code>ssh-agent</xhtml:code>
and <xhtml:code>ssh-add</xhtml:code>, and it looks something like this:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
#!/bin/bash
ssh-agent `ssh-add $OPENSHIFT_DATA_DIR/ssh/github-key &amp;&amp; (
    cd $OPENSHIFT_DATA_DIR/config ; 
    git fetch origin ; 
    git rebase origin/mwop.net.config
)`
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>After testing the above, I put this in a <xhtml:code>pre_build</xhtml:code>
script in my OpenShift configuration so that I can autoupdate my
private configuration on each build. However, I discovered a new
problem: when a build is being done, the <xhtml:code>ssh-agent</xhtml:code> is
not available, which means the above cannot be executed. I'm still
trying to find a solution.</xhtml:p>
<xhtml:h2>Fin</xhtml:h2>
<xhtml:p>I'm pretty happy with the move. I don't have to do anything
special to automate deployment, and all my cronjobs and deployment
scripts are now self-contained in the repository, which makes my
site more portable. While a few things could use more
documentation, all the pieces are there and discoverable with a
small amount of work.</xhtml:p>
<xhtml:p>I'll likely give some other PaaS providers a try in the future,
but for the moment, I'm quite happy with the functionality and
flexibility of OpenShift.</xhtml:p>
<xhtml:h4>Footnotes</xhtml:h4>
<xhtml:ul>
<xhtml:li id="f1">Zend Server's JobQueue can also be used as a cron
replacement, but I was not keen on exposing the job functionality
via HTTP.</xhtml:li>
</xhtml:ul>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[On php-fig and Shared Interfaces]]></title>
    <published>2012-12-20T20:23:00+0000</published>
    <updated>2012-12-20T20:23:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-12-20-on-shared-interfaces.html"/>
    <id>http://mwop.net/blog/2012-12-20-on-shared-interfaces.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>This is a post I've been meaning to write for a long time, and
one requested of me personally by <xhtml:a href="http://www.rooftopsolutions.nl/blog/">Evert Pot</xhtml:a> during the
Dutch PHP Conference in June 2012. It details some observations I
have of php-fig, and hopefully will serve as a record of why I'm
not directly participating any longer.</xhtml:p>
<xhtml:p>I was a founding member of the <xhtml:a href="http://www.php-fig.org/">Framework Interoperability Group</xhtml:a>, now
called "php-fig". I was one of around a dozen folks who sat around
a table in 2009 in Chicago during php|tek and started discussions
about what we could all do to make it possible to work better
together between our projects, and make it simpler for users to
pick and choose from our projects in order to build the solutions
to their own problems.</xhtml:p>
<xhtml:p>The first "standard" that came from this was <xhtml:a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">
PSR-0</xhtml:a>, which promoted a standard class naming convention that
uses a 1:1 relationship between the namespace and/or vendor prefix
and the directory hierarchy, and the class name and the filename in
which it lives. To this day, there are both those who hail this as
a great step forward for cooperation, and simultaneously others who
feel it's a terrible practice.</xhtml:p>
<xhtml:p>And then nothing, for years. But a little over a year ago, there
was a new push by a number of folks wanting to do more. Paul Jones
did a remarkable job of spearheading the next <xhtml:a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md">
two</xhtml:a> <xhtml:a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md">
standards</xhtml:a>, which centered around coding style. Again, just like
with PSR-0, we had both those feeling it was a huge step forward,
and those who loathe the direction.</xhtml:p>
<xhtml:p>What was interesting, though, was that once we started seeing
some new energy and momentum, it seemed that <xhtml:em>everyone</xhtml:em>
wanted a say. And we started getting dozens of folks a week asking
to be voting members, and new proposal after new proposal. Whether
or not somebody likes an existing standard, they want to have
backing for a standard they propose.</xhtml:p>
<xhtml:p>And this is when we started seeing proposals surface for shared
interfaces, first around caching, and now around logging (though
the latter is the first up for vote).</xhtml:p>
<xhtml:h2>Shared Interfaces</xhtml:h2>
<xhtml:p>The idea around shared interfaces is simple: if we can come to a
consensus on the basic interface for a common application task,
libraries and frameworks can typehint on that shared interface,
allowing developers to drop in the implementation of their choosing
-- or even a standard, reference implementation. The goal is to
prevent Not Invented Here (NIH) syndrome, as well as to make it
simpler to re-use components between one library and another. As an
example, if you're using Framework A, and it has a caching library,
and you're consuming ORM B, you'd be able to pass the same cache
object to the ORM as you use in the framework.</xhtml:p>
<xhtml:p>Great goals, really.</xhtml:p>
<xhtml:p>But I'm not sure I buy into them.</xhtml:p>
<xhtml:h2>Problems</xhtml:h2>
<xhtml:p>First, I agree that NIH is a problem.</xhtml:p>
<xhtml:p>Second, I <xhtml:em>also</xhtml:em> think there's space for <xhtml:em>multiple
implementations</xhtml:em> of any given component. Often there are
different approaches that different authors will take: one might
focus on performance, another on having multiple adapters for
providing different capabilities, etc. Sometimes having a different
background will present different problem areas you want to
resolve. As such, having multiple implementations can be a very
good thing; developers can look at what each provides, and
determine which solves the particular issues presented in the
current project.</xhtml:p>
<xhtml:p>Because of this latter point, I have my reservations about
shared interfaces.</xhtml:p>
<xhtml:p>What if a particular approach requires deviating from the shared
interface in order to accomplish its goals? Additionally, in order
to keep the greatest amount of compatibility between projects,
shared interfaces tend to be so generic that specific
implementations require developers to do a ton of manual type
checking and munging of parameters, leading to more overhead, more
difficulty testing and maintaining, and more difficulty documenting
and understanding.</xhtml:p>
<xhtml:p>As an example, consider the following (made up) signature for a
log method:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
public function log($message, array $context = null);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>What if your library supports an idea of priorities? Where would
that information go in the above signature -- and would that differ
between libraries -- would one library use the key for a completely
different purpose? What about logging objects -- the signature
doesn't say you can't, but how would I know if a specific
implementation supports it, and won't blow up if I do pass one? Why
must the <xhtml:code>$context</xhtml:code> be an array -- why won't any
<xhtml:code>Traversable</xhtml:code> or <xhtml:code>ArrayAccess</xhtml:code> object
work?</xhtml:p>
<xhtml:p>Basically, by being overly generic, the signature becomes a
liability for those implementing the interface; it prevents
meaningful interoperability and leads to splintering
implementations.</xhtml:p>
<xhtml:p><xhtml:em>(Please note: the above is completely fictional and has no
bearing on current proposed or accepted standards. It is a thought
exercise only.)</xhtml:em></xhtml:p>
<xhtml:p>Furthermore, if a given project writes their own implementation
of a component, and it has specialized features, why would they
want to typehint on a generic, shared interface that doesn't
implement those features? This would be counter-intuitive, as the
project would then need to either check on additional interfaces
for the specialized capabilities, duck-type, etc. -- all of which
make for more maintenance and code.</xhtml:p>
<xhtml:p>In summary, my primary problem with the idea of shared
interfaces is that I feel there is always room for new thinking and
ideas in any given problem space, and that this thinking should not
be restricted by what already exists. Secondarily, I feel that it's
okay for a given project to be selective about what capabilities it
requires for its internal consumption and consistency, and should
not limit itself to a standardized interface.</xhtml:p>
<xhtml:h2>But, but, SHARING</xhtml:h2>
<xhtml:p><xhtml:em>Remember, the first point I made was that I think NIH is a
problem.</xhtml:em> How do I reconcile that with a firm stance against
shared interfaces?</xhtml:p>
<xhtml:p>Easy: <xhtml:a href="http://en.wikipedia.org/wiki/Bridge_pattern">bridges</xhtml:a> and/or
<xhtml:a href="http://en.wikipedia.org/wiki/Adapter_pattern">adapters</xhtml:a>.</xhtml:p>
<xhtml:p>Let's go back to that example of Framework A, its caching
library, and working with ORM B.</xhtml:p>
<xhtml:p>Let's assume that ORM B defines an interface for caching, and
let's say it looks like this:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
interface CacheInterface
{
    public function set($key, $data);
    public function has($key);
    public function get($key);
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Furthermore, we'll assume that the expected parameter values and
return types are documented.</xhtml:p>
<xhtml:p>What we as a consumer of both Framework A and ORM B can do is
build an <xhtml:em>implementation</xhtml:em> of <xhtml:code>CacheInterface</xhtml:code>
that accepts a cache instance from Framework A, and proxies the
various interface methods to that instance.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
class FrameworkACache implements CacheInterface
{
    protected $cache;

    public function __construct(Cache $cache)
    {
        $this-&gt;cache = $cache;
    }

    public function set($key, $data)
    {
        $item = new CacheItem($key, $data);
        $this-&gt;cache-&gt;setItem($item);
    }

    public function has($key)
    {
        return $this-&gt;cache-&gt;exists($key);
    }

    public function get($key)
    {
        $item = $this-&gt;cache-&gt;getItem($key);
        return $item-&gt;getData();
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Assuming your code is well-decoupled, and you're using some sort
of Inversion of Control container, you can likely create a factory
for your ORM that will grab the above class, with the cache
injected, and inject it into the ORM instance. Yes, it's a bit more
work, but it's difficult to question the end result: shared caching
between the framework and the ORM - and no need for shared
interfaces, nor any need to sacrifice features within the framework
or the ORM.</xhtml:p>
<xhtml:h2>Sharing is good, developing solutions is better</xhtml:h2>
<xhtml:p>I think the core idea of the php-fig group is sound: <xhtml:em>let's
all start thinking about how we can make it easier to operate with
each other</xhtml:em>. That said, my thoughts on how to accomplish that
goal have changed significantly, and boil down to:</xhtml:p>
<xhtml:ul>
<xhtml:li>Use naming conventions that will reduce collisions (i.e., use
per-project vendor prefixes/namespaces)</xhtml:li>
<xhtml:li>Use semantic versioning</xhtml:li>
<xhtml:li>Keep your installation packages segregated</xhtml:li>
<xhtml:li>Have a simple, discoverable way to autoload</xhtml:li>
<xhtml:li>Provide interfaces for anything that could benefit from
alternate implementations</xhtml:li>
<xhtml:li>Don't write code that has side-effects in the global namespace
(including altering PHP settings or superglobals)</xhtml:li>
</xhtml:ul>
<xhtml:p>Following these principals, you can play nice with each other,
while still fostering innovative and differentiating solutions to
shared problems.</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[PHP Master Series on Day Camp For Developers]]></title>
    <published>2012-12-18T20:24:00+0000</published>
    <updated>2012-12-18T20:24:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-12-18-php-master-series.html"/>
    <id>http://mwop.net/blog/2012-12-18-php-master-series.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p><xhtml:a href="http://blog.calevans.com">Cal Evans</xhtml:a> has organized
another DayCamp4Developers event, this time entitled "<xhtml:a href="http://blog.calevans.com/2012/11/19/php-master-series-vol-1">PHP
Master Series, Volume 1</xhtml:a>". I'm honored to be an invited speaker
for this first edition, where I'll be presenting my talk,
"Designing Beautiful Software".</xhtml:p>
<xhtml:p>Why would you want to participate? Well, for one, because you
can interact directly with the various speakers during the
presentations. Sure, you can likely find the slide decks elsewhere,
or possibly even recordings. But if we all do our jobs right, we'll
likely raise more questions than answers; if you attend, you'll get
a chance to ask some of your questions immediately, <xhtml:em>and we may
even answer them!</xhtml:em></xhtml:p>
<xhtml:p>On top of that, this is a fantastic lineup of speakers, and,
frankly, not a lineup I've ever participated in. In a typical
conference, you'd likely see one or two of us, and be lucky if we
weren't scheduled against each other; if you attend this week,
you'll get to see us all, back-to-back.</xhtml:p>
<xhtml:p>What else will you be doing this Friday, anyways, while <xhtml:a href="http://en.wikipedia.org/wiki/2012_phenomenon">you wait for the end
of the world?</xhtml:a></xhtml:p>
<xhtml:p>So, do yourself a favor, and <xhtml:a href="http://phpmasterseriesv1.eventbrite.com/">register today</xhtml:a>!</xhtml:p>
</xhtml:div>
    </content>
  </entry>
</feed>
