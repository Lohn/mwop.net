<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Tag: http :: phly, boy, phly</title>
  <updated>2013-02-13T13:40:00+0000</updated>
  <generator uri="http://framework.zend.com" version="2.1.1dev">Zend_Feed_Writer</generator>
  <link rel="alternate" type="text/html" href="http://mwop.net/blog/tag/http.html"/>
  <link rel="self" type="application/atom+xml" href="http://mwop.net/blog/tag/http-atom.xml"/>
  <id>http://mwop.net/blog/tag/http.html</id>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[RESTful APIs with ZF2, Part 2]]></title>
    <published>2013-02-13T13:40:00+0000</published>
    <updated>2013-02-13T13:40:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2013-02-13-restful-apis-with-zf2-part-2.html"/>
    <id>http://mwop.net/blog/2013-02-13-restful-apis-with-zf2-part-2.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>In my <xhtml:a href="/blog/2013-02-11-restful-apis-with-zf2-part-1.html">last post</xhtml:a>,
I covered some background on REST and the Richardson Maturity
Model, and some emerging standards around hypermedia APIs in JSON;
in particular, I outlined aspects of Hypermedia Application
Language (HAL), and how it can be used to define a generic
structure for JSON resources.</xhtml:p>
<xhtml:p>In this post, I cover an aspect of RESTful APIs that's often
overlooked: reporting problems.</xhtml:p>
<xhtml:h2>Background</xhtml:h2>
<xhtml:p>APIs are useful when they're working. But when they fail,
they're only useful if they provide us with meaningful information;
if all I get is a status code, and no indication of what caused the
issue, or where I might look for more information, I get
frustrated.</xhtml:p>
<xhtml:p>In consuming APIs, I've come to the following conclusions:</xhtml:p>
<xhtml:ul>
<xhtml:li>Error conditions need to provide detailed information as to
what went wrong, and what steps I may be able to take next. An
error code with no context gives me nothing to go on.</xhtml:li>
<xhtml:li>Errors need to be reported consistently. Don't report the error
one way one time, and another way the next.</xhtml:li>
<xhtml:li><xhtml:strong>DO</xhtml:strong> use HTTP status codes to indicate an error
happened. Nothing is more irksome than getting back a 200 status
with an error payload.</xhtml:li>
<xhtml:li>Errors should be reported in a format I have indicated I will
Accept (as in the HTTP header). Perhaps the only think more irksome
than a 200 status code for an error is getting back an HTML page
when I expect JSON.</xhtml:li>
</xhtml:ul>
<xhtml:h2>Why Status Codes Aren't Enough</xhtml:h2>
<xhtml:p>Since REST leverages and builds on HTTP, an expedient solution
for reporting problems is to simply use <xhtml:a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">HTTP
status codes</xhtml:a>. These are well understood by web developers,
right?</xhtml:p>
<xhtml:p><xhtml:code>4xx</xhtml:code> error codes are errors made by the requestor,
and are actually fairly reasonable to use for reporting things such
as lack of authorization tokens, incomplete requests, unsupportable
operations, or non-supported media types.</xhtml:p>
<xhtml:p>But what happens when the error is on the server - because
something has gone wrong such as inability to reach your
persistence layer or credential storage? The <xhtml:code>5xx</xhtml:code>
series of status codes is sparse and wholly unsuited to reporting
errors of these types -- <xhtml:em>though you'll likely still want to use
a <xhtml:code>500</xhtml:code> status to report the failure</xhtml:em>. But what do
you present to the consumer so that they know whether or not to try
again, or what to report to you so that you can fix the issue?</xhtml:p>
<xhtml:p>A status code simply isn't enough information most of the time.
Yes, you want to define standard status codes so that your clients
can perform reasonable branching, but you also need a way to
communicate <xhtml:em>details</xhtml:em> to the end-user, so that they can log
the information for themselves, display information to their own
end-users, and/or report it back to you so you can do something to
resolve the situation.</xhtml:p>
<xhtml:h2>Custom Media Types</xhtml:h2>
<xhtml:p>The first step is to use a custom media type. Media types are
typically both a name as well as a structure -- and the latter is
what we're after when it comes to error reporting.</xhtml:p>
<xhtml:p>If we return a response using this media type, the client then
knows how to parse it, and can then process it, log it,
whatever.</xhtml:p>
<xhtml:p>Sure, you can make up your own format -- as long as you are
consistent in using it, and you document it. But personally, I
don't like inventing new formats when standard formats exist
already. Custom formats mean that custom clients are required for
working with the services; using a standard format can save effort
and time.</xhtml:p>
<xhtml:p>In the world of JSON, I've come across two error media types
that appear to be gaining traction:
<xhtml:code>application/api-problem+json</xhtml:code> and
<xhtml:code>application/vnd.error+json</xhtml:code></xhtml:p>
<xhtml:h3>API-Problem</xhtml:h3>
<xhtml:p>This particular media type is <xhtml:a href="http://tools.ietf.org/html/draft-nottingham-http-problem-02">via
the IETF</xhtml:a>. Like HAL, it provides formats in both JSON and XML,
making it a nice cross-platform choice.</xhtml:p>
<xhtml:p>As noted already, the media type is
<xhtml:code>application/api-problem+json</xhtml:code>. The representation is a
single resource, with the following properties:</xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:strong>describedBy</xhtml:strong>: a URL to a document describing
the error condition (required)</xhtml:li>
<xhtml:li><xhtml:strong>title</xhtml:strong>: a brief title for the error condition
(required)</xhtml:li>
<xhtml:li><xhtml:strong>httpStatus</xhtml:strong>: the HTTP status code for the
current request (optional)</xhtml:li>
<xhtml:li><xhtml:strong>detail</xhtml:strong>: error details specific to this request
(optional)</xhtml:li>
<xhtml:li><xhtml:strong>supportId</xhtml:strong>: a URL to the specific problem
occurrence (e.g., to a log message) (optional)</xhtml:li>
</xhtml:ul>
<xhtml:p>As an example:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
HTTP/1.1 500 Internal Error
Content-Type: application/api-problem+json

{
    "describedBy": "http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html",
    "detail": "Status failed validation",
    "httpStatus": 500,
    "title": "Internal Server Error"
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The specification allows a large amount of flexibility -- you
can have your own custom error types, so long as you have a
description of them to link to. You can provide as little or as
much detail as you want, and even decide what information to expose
based on environment.</xhtml:p>
<xhtml:p>I personally like to point to the HTTP status code definitions,
and then provide request-specific detail; I find this gives quick
and simple results that I can later shape as I add more detail to
my API. However, the specification definitely encourages you to
have unique error types with discrete URIs that describe them --
never a bad thing when creating APIs.</xhtml:p>
<xhtml:h3>vnd.error</xhtml:h3>
<xhtml:p>This is a <xhtml:a href="https://github.com/blongden/vnd.error">proposed media type</xhtml:a>
within the HAL community. Like HAL, it provides formats in both
JSON and XML, making it a nice cross-platform choice.</xhtml:p>
<xhtml:p>It differentiates from API-Problem in a few ways. First, it
allows, and even encourages, reporting collections of errors. If
you consider PHP exceptions and the fact that they support
"previous" exceptions, this is a powerful concept; you can report
the entire chain of errors that led to the response. Second, it
encourages pushing detail out of the web service; errors include a
"logRef" property that points to where the error detail lives. This
is probably better illustrated than explained.</xhtml:p>
<xhtml:p>The response payload is an array of objects. Each object has the
following members:</xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:strong>logRef</xhtml:strong>: a unique identifier for the specific
error which can then be used to identify the error within
server-side logs (required)</xhtml:li>
<xhtml:li><xhtml:strong>message</xhtml:strong>: the error message itself
(required)</xhtml:li>
<xhtml:li><xhtml:strong>_links</xhtml:strong>: HAL-compatible links. Typically,
"help", "describes", and/or "describedBy" relations will be defined
here.</xhtml:li>
</xhtml:ul>
<xhtml:p>As an example, let's consider the API-Problem example I had
earlier, and provide a vnd.error equivalent:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
HTTP/1.1 500 Internal Error
Content-Type: application/vnd.error+json

[
    {
        "logRef": "someSha1HashMostLikely",
        "message": "Status failed validation",
        "_links": {
            "describedBy": {"href": "http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html"}
        }
    }
]
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>vnd.error basically begs you to create custom error types, with
documentation end-points that detail the source of the error and
what you can do about it (this is true of API-Problem as well).</xhtml:p>
<xhtml:p>The requirement to include a log reference ("logRef") and have
it be unique can be a stumbling block to implementation, however,
as it requires effort for uniquely identifying requests, and
logging. However, both the identification and logging can be
automated.</xhtml:p>
<xhtml:h2>Summary</xhtml:h2>
<xhtml:p>Error reporting in APIs is as important as the normal resource
payloads themselves. Without good error reporting, when an API
raises errors, clients have difficulty understanding what they can
do next, and cannot provide you, the API provider, with information
that will allow you to debug on the server side.</xhtml:p>
<xhtml:p>As noted at the beginning of the article, if you follow the
rules below, you'll make consumers of your API happier and more
productive.</xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:strong>DO</xhtml:strong> use appropriate HTTP status codes to
indicate an error happened.</xhtml:li>
<xhtml:li>Report errors in a format I have indicated I will Accept (as in
the HTTP header).</xhtml:li>
<xhtml:li>Report errors consistently. Don't report the error one way one
time, and another way the next. Standardize on a specific
error-reporting media type . While you <xhtml:em>can</xhtml:em> create your own
error structure, I recommend using documented, accepted standards.
This will make clients more re-usable, and make many of your
decisions for you.</xhtml:li>
<xhtml:li>Provide detailed information as to what went wrong, and what
steps I may be able to take next. Provide documentation for each
type of error, and link to that documentation from your error
payloads.</xhtml:li>
</xhtml:ul>
<xhtml:p>Which brings me to...</xhtml:p>
<xhtml:h2>Next time</xhtml:h2>
<xhtml:p>I realize I still haven't covered anything specific to ZF2, but
I'll start next time, when I cover the next topic: documenting your
API. An undocumented API is a useless API, so it's good to start
baking documentation in immediately. I'll survey some of the
possibilities and how they can be implemented in ZF2 in the next
installment, and then we can get our hands dirty with actual API
development.</xhtml:p>
<xhtml:h3>Updates</xhtml:h3>
<xhtml:p><xhtml:em>Note: I'll update this post with links to the other posts in
the series as I publish them.</xhtml:em></xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:a href="/blog/2013-02-11-restful-apis-with-zf2-part-1">Part
1</xhtml:a></xhtml:li>
</xhtml:ul>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[RESTful APIs with ZF2, Part 1]]></title>
    <published>2013-02-12T11:42:00+0000</published>
    <updated>2013-02-13T13:40:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2013-02-11-restful-apis-with-zf2-part-1.html"/>
    <id>http://mwop.net/blog/2013-02-11-restful-apis-with-zf2-part-1.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>RESTful APIs have been an interest of mine for a couple of
years, but due to <xhtml:a href="http://framework.zend.com/blog//zend-framework-2-0-0-stable-released.html">
circumstances</xhtml:a>, I've not had much chance to work with them in
any meaningful fashion until recently.</xhtml:p>
<xhtml:p><xhtml:a href="http://akrabat.com/">Rob Allen</xhtml:a> and I proposed a
workshop for <xhtml:a href="http://conference.phpbenelux.eu/2013/">PHP
Benelux 2013</xhtml:a> covering RESTful APIs with ZF2. When it was
accepted, it gave me the perfect opportunity to dive in and start
putting the various pieces together.</xhtml:p>
<xhtml:h2>Background</xhtml:h2>
<xhtml:p>I've attended any number of conference sessions on API design,
read countless articles, and engaged in quite a number of
conversations. Three facts keep cropping up:</xhtml:p>
<xhtml:ol>
<xhtml:li>JSON is fast becoming the preferred exchange format due to the
ease with which it de/serializes in almost every language.</xhtml:li>
<xhtml:li>The "holy grail" is <xhtml:a href="http://martinfowler.com/articles/richardsonMaturityModel.html">Richardson
Maturity Model</xhtml:a> Level 3.</xhtml:li>
<xhtml:li>It's really hard to achieve RMM level 3 with JSON.</xhtml:li>
</xhtml:ol>
<xhtml:h3>Richardson Maturity Model</xhtml:h3>
<xhtml:p>As a quick review, the Richardson Maturity Model has the
following 4 levels:</xhtml:p>
<xhtml:ul>
<xhtml:li>Level 0: "The swamp of POX." Basically, a service that uses TCP
for transport, primarily as a form of remote procedure call (RPC).
Typically, these are not really leveraging HTTP in any meaningful
fashion; most systems will use HTTP POST for all interactions.
Also, you will often have a single endpoint for all interactions,
regardless of whether or not they are strictly related. XML-RPC,
SOAP, and JSON-RPC fall under this category.</xhtml:li>
<xhtml:li>Level 1: "Resources." In these services, you start breaking the
service into multiple services, one per "resource," or, in object
oriented terms, per object. This means a distinct URL per object,
which means each has its own distinct identity on the web; this
often extends not only to the collection of objects, but to
individual objects under the collection as well (e.g., "/books" as
well as "/books/life-of-pi"). The service may still be RPC in
nature, however, and, at this level, often is still using a single
HTTP method for all interactions with the resource.</xhtml:li>
<xhtml:li>Level 2: "HTTP Verbs." At this level, we start using HTTP verbs
with our services in the way the HTTP specification intends. GET is
for safe operations, and should be cacheable; POST is used for
creation and/or updating; DELETE can be used to delete a resource;
etc. Rather than doing RPC style methods, we leverage HTTP,
occasionally passing additional parameters via the query string or
request body. Considerations such as HTTP caching and idempotence
are taken into account.</xhtml:li>
<xhtml:li>Level 3: "Hypermedia Controls." Building on the previous level,
our resource representations now also include <xhtml:em>links</xhtml:em>, which
indicate what we can <xhtml:em>do next</xhtml:em>. At this level, our API
becomes practically self-describing; given a single end-point, we
should be able to start crawling it, using the links in a
representation to lead us to the next actions.</xhtml:li>
</xhtml:ul>
<xhtml:p>When I first started playing with web services around a decade
ago, everything was stuck at Level 0 or Level 1 -- usually with
Level 1 users downgrading to Level 0 because Level 0 offerred
consistency and predictability if you chose to use a service type
that had a defined envelope format (such as XML-RPC or SOAP). (I
even wrote the XML-RPC server implementation for Zend Framework
because I got sick of writing one-off parsers/serializers for
custom XML web service implementations. When you're implementing
many services, predictability is a huge win.)</xhtml:p>
<xhtml:p>A few years ago, I started seeing a trend towards Level 2. Web
developers like the simplicity of using HTTP verbs, as they map
very well to <xhtml:a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</xhtml:a>
operations -- the bread and butter of web development. Couple this
concept with JSON, and it becomes trivially simple to both create a
web service, as well as consume it.</xhtml:p>
<xhtml:p><xhtml:em>I'd argue that the majority of web developers are quite
happy to be at Level 2 -- and have no problem staying there.
They're productive, and the concepts are easy -- both to understand
and to implement.</xhtml:em></xhtml:p>
<xhtml:p>Level 3, though, is where it becomes really interesting. The
idea that I can examine the represention <xhtml:em>alone</xhtml:em> in order to
understand what I can do next is very intriguing and
empowering.</xhtml:p>
<xhtml:h3>JSON and Hypermedia</xhtml:h3>
<xhtml:p>With XML, hypermedia basically comes for free. Add some
&lt;link&gt; elements to your representation, and you're done --
and don't forget the link <xhtml:code>rel</xhtml:code>ations!</xhtml:p>
<xhtml:p>JSON, however, is another story.</xhtml:p>
<xhtml:p>Where do the links go? <xhtml:em>There is no single, defined way to
represent a hyperlink in JSON.</xhtml:em></xhtml:p>
<xhtml:p>Fortunately, there are some emerging standards.</xhtml:p>
<xhtml:p>First is use of the <xhtml:a href="http://www.w3.org/wiki/LinkHeader">"Link" HTTP header</xhtml:a>. While
the page I linked shows only a single link in the header, you can
have multiple links separated by commas. GitHub uses this when
providing pagination links in their API. Critics will point out
that the HTTP headers are not technically part of the
representation, however; strict interpetations of REST and RMM
indicate that the hypermedia links should be part of the resource
representation. Regardless, having the links in the HTTP headers is
useful for pre-traversal of a service, as you can perform HEAD
requests only to discover possible actions and workflows.</xhtml:p>
<xhtml:p><xhtml:a href="http://amundsen.com/media-types/collection/format/">Collection+JSON</xhtml:a>
is interesting, as it describes the entire JSON envelope. My one
criticism is that it details too much; whenever I see a format that
dictates how to describe types, I think of XML-RPC or SOAP, and get
a little twitchy. It's definitely worth a look, though.</xhtml:p>
<xhtml:p>What's captured my attention of late, however, is <xhtml:a href="http://stateless.co/hal_specification.html">Hypertext Application
Language</xhtml:a>, or HAL for short. HAL has very few rules, but
succinctly describes both how to provide hypermedia in JSON as well
as how to represent embedded resources - the two things that most
need standardized structure in JSON. It does this while still
providing a generic media type, and also describing a mirror image
XML format!</xhtml:p>
<xhtml:h3>HAL Media Types</xhtml:h3>
<xhtml:p>HAL defines two generic media types:
<xhtml:code>application/hal+xml</xhtml:code> and
<xhtml:code>application/hal+json</xhtml:code>. You will use these as the
response Content-Type, as they describe the response
representation; the client can simply request
<xhtml:code>application/json</xhtml:code>, and the response format remains
compatible.</xhtml:p>
<xhtml:h3>HAL and Links</xhtml:h3>
<xhtml:p>HAL provides a very simple structure for JSON hypermedia links.
First, all resource representations must contain hypermedia links,
and all links are provided in a "_links" object:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Second, links are properties of this object. The property name
is the link relation, and the value is an object containing
minimally an "href" property.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status/1234"}
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>If a given relation can have multiple links, you provide instead
an array of objects:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status/1234"},
        "conversation": [
            {"href": "http://example.com/api/status/1237"},
            {"href": "http://example.com/api/status/1241"}
        ]
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Individual links can contain other attributes as desired -- I've
seen people include the relation again so that it's self-contained
in the link object, and it's not uncommon to include a title or
name.</xhtml:p>
<xhtml:h3>HAL and Resources</xhtml:h3>
<xhtml:p>HAL imposes no structure over resources other than requiring the
hypermedia links; even then, you typically do not include the
hypermedia links when making a request of the web service; the
hypermedia links are included only in the representations
<xhtml:em>returned</xhtml:em> by the service.</xhtml:p>
<xhtml:p>So, as an example, you would POST the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
POST /api/status
Host: example.com
Accept: application/json
Content-Type: application/json

{
    "status": "This is my awesome status update!",
    "user": "mwop"
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>And from that request, you'd receive the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
201 Created
Location: http://example.com/api/status/1347
Content-Type: application/hal+json

{
    "_links": {
        "self": {"href": "http://example.com/api/status/1347"}
    },
    "id": "1347",
    "timestamp": "2013-02-11 23:33:47",
    "status": "This is my awesome status update!",
    "user": "mwop"
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:h3>HAL and Embedded Resources</xhtml:h3>
<xhtml:p>The other important thing that HAL defines is how to
<xhtml:em>embed</xhtml:em> resources. Why is this important? If the resource
references other resources, you will want to be able to link to
them so you can perform operations on them, too.</xhtml:p>
<xhtml:p>Embedded resources are represented inside an "_embedded" object
of the representation, and, as resources, contain their own
"_links" object as well. Each resource you embed is assigned to a
property of that object, and if multiple objects of the same type
are returned, an array of resources is assigned. In fact, this
latter is how you represent <xhtml:em>collections</xhtml:em> in HAL.</xhtml:p>
<xhtml:p>Let's consider a simple example first. In previous code samples,
I have a "user" that's a string; let's make that an embedded
resource instead.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status/1347"}
    },
    "id": "1347",
    "timestamp": "2013-02-11 23:33:47",
    "status": "This is my awesome status update!",
    "_embedded": {
        "user": {
            "_links": {
                "self": {"href": "http://example.com/api/user/mwop"}
            }
            "id": "mwop",
            "name": "Matthew Weier O'Phinney",
            "url": "http://mwop.net"
        }
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>I've moved the "user" out of the representation, and into the
"_embedded" object -- because this is where you define embedded
resources. Note that the "user" is a standard HAL resource itself
-- containing hypermedia links.</xhtml:p>
<xhtml:p>Now let's look at a collection:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status"},
        "next": {"href": "http://example.com/api/status?page=2"},
        "last": {"href": "http://example.com/api/status?page=100"}
    },
    "count": 2973,
    "per_page": 30,
    "page": 1,
    "_embedded": {
        "status": [
            {
                "_links": {
                    "self": {"href": "http://example.com/api/status/1347"}
                },
                "id": "1347",
                "timestamp": "2013-02-11 23:33:47",
                "status": "This is my awesome status update!",
                "_embedded": {
                    "user": {
                        "_links": {
                            "self": {"href": "http://example.com/api/user/mwop"}
                        }
                        "id": "mwop",
                        "name": "Matthew Weier O'Phinney",
                        "url": "http://mwop.net"
                    }
                }
            }
            /* ... */
        ]
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Note that the "status" property is an array; semantically, all
resources under this key are of the same type. Also note that the
parent resource has some additional link relations -- these are
related to pagination, and allow a client to determine what the
next and last pages are (and, if we were midway into the
collection, previous and first pages). Since the collection is also
a resource, it has some interesting metadata -- how many resources
are in the collection, how many we represent per page, and what the
current page is.</xhtml:p>
<xhtml:p>Also note that you can nest resources -- simply include an
"_embedded" object inside an embedded resource, with additional
resources, as I've done with the "user" resource inside the status
resource shown here. It's turtles all the way down.</xhtml:p>
<xhtml:h2>Next Time</xhtml:h2>
<xhtml:p>The title of this post indicates I'll be talking about building
RESTful APIs with ZF2 -- but so far, I've not said anything about
ZF2.</xhtml:p>
<xhtml:p>I'll get there. But there's another detour to take: reporting
errors.</xhtml:p>
<xhtml:h3>Updates</xhtml:h3>
<xhtml:p><xhtml:em>Note: I'll update this post with links to the other posts in
the series as I publish them.</xhtml:em></xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:a href="/blog/2013-02-13-restful-apis-with-zf2-part-2">Part
2</xhtml:a></xhtml:li>
</xhtml:ul>
</xhtml:div>
    </content>
  </entry>
</feed>
