<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/">
  <channel>
    <title>Tag: javascript :: phly, boy, phly</title>
    <description>Tag: javascript :: phly, boy, phly</description>
    <pubDate>Thu, 08 May 2014 17:00:00 +0000</pubDate>
    <generator>Zend_Feed_Writer 2 (http://framework.zend.com)</generator>
    <link>http://mwop.net/blog/tag/javascript.html</link>
    <atom:link rel="self" type="application/rss+xml" href="http://mwop.net/blog/tag/javascript-rss.xml"/>
    <item>
      <title>A Better $state.reload for the AngularJS UI-Router</title>
      <pubDate>Thu, 08 May 2014 17:00:00 +0000</pubDate>
      <link>http://mwop.net/blog/2014-05-08-angular-ui-router-reload.html</link>
      <guid>http://mwop.net/blog/2014-05-08-angular-ui-router-reload.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    While working on <a href="http://apigility.org/">Apigility</a>, several times I ran into
    an odd issue: after fetching new data via an API and assigning it to a scoped variable,
    content would flash into existence... and then disappear. Nothing would cause it to display
    again other than a browser reload of the page.
</p><h2>Setup</h2>

<p>
    I have a page that lists a set of items. When you create an item, you push data to the API,
    and, when done, the new item should be in that list.
</p>

<h2>First try: append to list</h2>

<p>
    My first attempt was just appending the data to the list.
</p>

<div class="example"><pre><code language="javascript">
service.create(data).then(function (newItem) {
    flash.success = 'Successfully created something';
    /* append new item to list */
    $scope.services.push(newItem);
});
</code></pre></div>

<p>
    This worked... until you left that screen and returned. At that point, the 
    new item would be gone, even if I coded my ui-router states to force a cache
    refresh.
</p>

<h2>Refresh list</h2>

<p>
    My next attempt was to write a routine that would do a cache refresh after
    creating the new item.
</p>

<div class="example"><pre><code language="javascript">
service.create(data).then(function (newItem) {
    flash.success = 'Successfully created something';
    service.fetchAll(var force = true).then(function (services) {
        $scope.services = services;
    });
});
</code></pre></div>

<p>
    This is when I started noticing the "flash of content" problem. Essentially, immediately
    after fetching the set of services, you'd see the new item appended... and then it would
    disappear.
</p>

<h2>$state.reload()</h2>

<p>
    At this point, I figured I'd use the ui-router to force a refresh, specifically via
    <code>$state.reload()</code>.
</p>

<div class="example"><pre><code language="javascript">
service.create(data).then(function (newItem) {
    flash.success = 'Successfully created something';
    service.fetchAll(var force = true).then(function (services) {
        $scope.services = services;
        $state.reload();
    });
});
</code></pre></div>

<p>
    I tried both with and without setting the scoped variable. Initially, I thought it was
    working -- but, as it turned out, I missed a case. I tested every single time with at
    least one item already in the list -- and this approach worked. However, when I tried
    with the list not yet populated, failure once again.
</p>

<h2>Success: $timeout</h2>

<p>
    Surprisingly, the least intuitive solution ended up working: introducing a delay.
</p>

<div class="example"><pre><code language="javascript">
service.create(data).then(function (newItem) {
    flash.success = 'Successfully created something';
    service.fetchAll(var force = true)
        .then(function (services) {
            $scope.services = services;
        }).then(function () {
            return $timeout(function () {
                $state.go('.', {}, { reload: true });
            }, 100);
        });
});
</code></pre></div>

<p>
    I have a few things to note about this. First, I moved the "reload" into its own promise. This was done
    to ensure it doesn't block on the scope assignment. Second, I introduce a <code>$timeout</code>
    call. This essentially gives the scope a chance to populate before the reload triggers. Some
    examples I saw did a 1ms timeout; I found in practice that this was not long enough; 100ms was
    long enough, and did not introduce a noticeable delay in UI responsiveness. Finally, you'll
    note this does not use <code>$state.reload()</code>. This is due to discovering that part of my
    problem is a <a href="https://github.com/angular-ui/ui-router/issues/582">known bug in <code>$state.reload()</code></a>,
    whereby state "resolve" configuration is not honored.
</p>

<p>
    I hope this approach helps others -- I've found it to be robust and predictable.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>A Bower Primer</title>
      <pubDate>Tue, 03 Dec 2013 15:50:00 +0000</pubDate>
      <link>http://mwop.net/blog/2013-12-03-bower-primer.html</link>
      <guid>http://mwop.net/blog/2013-12-03-bower-primer.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    Recently, I've been doing a fair bit of frontend development with my team 
    as we've worked on the <a href="http://apigility.org/">Apigility</a> admin.
    This has meant working with a variety of both JavaScript and CSS
    libraries, often trying something out only to toss it out again later.
    Working with frontend libraries has been quite a hassle, due to a combination
    of discovery, installation issues, and build issues (minimization, primarily).
    I figured there must a better way.
</p><h2>Background</h2>

<p>
    Until recently, discovery of JS and CSS libraries has gone something like this:
</p>

<ol>
    <li>Search for functionality via Google</li>
    <li>Generally find a solution on StackOverflow</li>
    <li>Discover said solution relies on a third-party library</li>
    <li>Google for said library</li>
    <li>Generally find said library on GitHub</li>
    <li>Clone the library locally</li>
    <li>Either build the final assets, or try and locate them in the repo</li>
    <li>Minimize the assets</li>
    <li>Copy the assets into the project</li>
</ol>

<p>
    Frontend development sucks.
</p>

<p>
    Then I started noticing these files called <code>.bowerrc</code> and 
    <code>bower.json</code> in many of the aforementioned libraries, and also
    that <a href="http://ralphschindler.com/">Ralph</a> had put some inside our
    Apigility skeleton. I got curious as to what this "bower" might be.
</p>

<h2>Bower: Package management for the web</h2>

<p>
    Essentially, <a href="http://bower.io/">Bower</a> is, to use the project's
    words, "a package manager for the web." Written in JavaScript, and running
    on <a href="http://nodejs.org/">node.js</a>, it is to frontend assets what
    <a href="https://npmjs.org/">npm</a> is to node, or <a href="https://getcomposer.org">Composer</a> 
    is to PHP. It allows you to define what assets you need in your application,
    including the versions, and then install them. If any of those assets have
    other dependencies, those, too, will be installed.
</p>

<p>
    Later, you can update the dependencies, add or remove dependencies, and more.
</p>

<p>
    On top of that, bower allows you to <em>search</em> for packages, which
    essentially allows you to eliminate most of the steps 4 and on in my list
    above.
</p>

<h2>A Bower Primer</h2>

<p>So, how do you use bower?</p>

<p>
    In my experience, which is not extensive by any stretch, the usage is like this:
</p>

<ol>
    <li>Search for functionality via Google</li>
    <li>Generally find a solution on StackOverflow</li>
    <li>Discover said solution relies on a third-party library</li>
    <li>Use bower to search for said library</li>
    <li>Add the discovered library to your <code>bower.json</code> file</li>
    <li>Run <code>bower install</code> or <code>bower update</code></li>
</ol>

<p>
    I've found that most projects registered with bower have minimized builds
    available (as well as the full source build), which is a huge boon in
    terms of performance. It also eliminates the "minimize the assets" step from
    my original list.
</p>

<p>
    To use bower, you'll need two files. The first is <code>.bowerrc</code> 
    which goes in your project root; you'll run <code>bower</code> from this 
    same directory.  This file tells bower how to run, and where to install 
    things, and, despite being an RC file, is written in JSON. Mine usually 
    looks like this:
</p>

<div class="example"><pre><code language="javascript">
{
    "directory": "public/assets/vendor"
}
</code></pre></div>

<p>
    The above tells bower to install dependencies in the <code>public/assets/vendor</code>
    subdirectory.
</p>

<p>
    The second file you need is <code>bower.json</code>. This file tells bower
    what asset packages you want to install, and the preferred version. (The file
    can also be used to define a package, just like with Composer or npm.) As an
    example, the following is a definition I used for an Apigility example:
</p>

<div class="example"><pre><code language="javascript">
{
    "name": "ag-contacts-demo",
    "version": "0.0.1",
    "ignore": [
        "**/.*"
    ],
    "dependencies": {
        "angular": "~1.2",
        "angular-resource": "~1.2",
        "angular-route": "~1.2",
        "bootstrap": ">=3.0.0",
        "font-awesome": "~3.2.1"
    }
}
</code></pre></div>

<p>
    Bower requires that packages use <a href="http://semver.org/">Semantic
    Versioning</a>. You can specify exact versions, minor versions, or major
    versions, combine them with comparison operators (<code>&lt;</code>, 
    <code>&gt;</code>, <code>=</code>, etc.), or use the "next significant release"
    operator ("~") to indicate a given version up to the next more general
    release (e.g., "~1.2" is equivalent to "&gt;=1.2,&lt;2.0").
</p>

<p>
    Once you have these defined, you should also add an entry to your 
    <code>.gitignore</code> file to exclude the directory you list in your
    <code>.bowerrc</code>; these files can be installed at build time,
    and thus help you keep your project repository lean. Per the above
    example:
</p>

<div class="example"><pre><code language="text">
public/assets/vendor/
</code></pre></div>

<p>
    At this point, run <code>bower install</code>, and bower will resolve
    all dependencies and install them where you want.
</p>

<p>
    At any point, you can list what packages bower has installed, as well
    as the versions it has installed. The <code>bower help</code> command
    is your friend should those needs arise.
</p>

<h2>Closing Thoughts</h2>

<p>
    I'm quite happy with the various tools emerging to make modern
    web development easier by allowing developers to more easily
    share their work, as well as ensure that all dependencies are
    easily installable. Bower is another tool in my arsenal as a web
    developer, giving me a consistent set of dependency management tools from my 
    server-side development all the way to my client-side application.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
  </channel>
</rss>
