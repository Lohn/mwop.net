<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Tag: rest :: phly, boy, phly</title>
  <updated>2013-02-25T12:29:00+0000</updated>
  <generator uri="http://framework.zend.com" version="2">Zend_Feed_Writer</generator>
  <link rel="alternate" type="text/html" href="http://mwop.net/blog/tag/rest.html"/>
  <link rel="self" type="application/atom+xml" href="http://mwop.net/blog/tag/rest-atom.xml"/>
  <id>http://mwop.net/blog/tag/rest.html</id>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[RESTful APIs with ZF2, Part 3]]></title>
    <published>2013-02-25T12:29:00+0000</published>
    <updated>2013-02-25T12:29:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2013-02-25-restful-apis-with-zf2-part-3.html"/>
    <id>http://mwop.net/blog/2013-02-25-restful-apis-with-zf2-part-3.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>In my <xhtml:a href="/blog/2013-02-11-restful-apis-with-zf2-part-1.html">previous</xhtml:a>
<xhtml:a href="/blog/2013-02-13-restful-apis-with-zf2-part-2.html">posts</xhtml:a>, I
covered basics of JSON hypermedia APIs using Hypermedia Application
Language (HAL), and methods for reporting errors, including
API-Problem and vnd.error.</xhtml:p>
<xhtml:p>In this post, I'll be covering <xhtml:em>documenting</xhtml:em> your API --
techniques you can use to indicate what HTTP operations are
allowed, as well as convey the full documentation on what endpoints
are available, what they accept, and what you can expect them to
return.</xhtml:p>
<xhtml:p>While I will continue covering general aspects of RESTful APIs
in this post, I will also finally introduce several ZF2-specific
techniques.</xhtml:p>
<xhtml:h2>Why Document?</xhtml:h2>
<xhtml:p>If you're asking this question, you've either never consumed
software, or your software is perfect and self-documenting. I
frankly don't believe either one.</xhtml:p>
<xhtml:p>In the case of APIs, those consuming the API need to know how to
use it.</xhtml:p>
<xhtml:ul>
<xhtml:li>What endpoints are available? Which operations are available
for each endpoint?</xhtml:li>
<xhtml:li>What does each endpoint expect as a payload during the
request?</xhtml:li>
<xhtml:li>What can you expect as a payload in return?</xhtml:li>
<xhtml:li>How will errors be communicated?</xhtml:li>
</xhtml:ul>
<xhtml:p>While the promise of hypermedia APIs is that each response tells
you the next steps available, you still, somewhere along the way,
need more information - what payloads look like, which HTTP verbs
should be used, and more. If you're <xhtml:strong>not</xhtml:strong>
documenting your API, you're "doing it wrong."</xhtml:p>
<xhtml:h2>Where Should Documentation Live?</xhtml:h2>
<xhtml:p>This is the much bigger question.</xhtml:p>
<xhtml:p>Of the questions I raised above, detailing what should be
documented, there are two specific types. When discussing what
operations are available, we have a technical solution in the form
of the <xhtml:code>OPTIONS</xhtml:code> method and its counterpart, the
<xhtml:code>Allow</xhtml:code> header. Everything else falls under end-user
documentation.</xhtml:p>
<xhtml:h2>OPTIONS</xhtml:h2>
<xhtml:p>The HTTP specification details the <xhtml:code>OPTIONS</xhtml:code> method
as idempotent, non-cacheable, and for use in detailing what
operations are available for the given resource specified by the
request URI. It makes specific mention of the <xhtml:code>Allow</xhtml:code>
header, but does not limit what is returned for requests made via
this method.</xhtml:p>
<xhtml:p>The <xhtml:code>Allow</xhtml:code> header details the allowed HTTP methods
for the given resource.</xhtml:p>
<xhtml:p>Used in combination, you make an <xhtml:code>OPTIONS</xhtml:code> request to
a URI, and it should return a response containing an
<xhtml:code>Allow</xhtml:code> header; from that header value, you then know
what other HTTP methods can be made to that URI.</xhtml:p>
<xhtml:p>What this tells us is that our RESTful endpoint should do the
following:</xhtml:p>
<xhtml:ul>
<xhtml:li>When an <xhtml:code>OPTIONS</xhtml:code> request is made, return a response
with an <xhtml:code>Allow</xhtml:code> header that has a list of the available
HTTP methods allowed.</xhtml:li>
<xhtml:li>For any HTTP method we do <xhtml:em>not</xhtml:em> allow, we should return
a "405 Not Allowed" response.</xhtml:li>
</xhtml:ul>
<xhtml:p>These are fairly easy to accomplish in ZF2. <xhtml:em>(See? I promised
I'd get to some ZF2 code in this post!)</xhtml:em></xhtml:p>
<xhtml:p>When creating RESTful endpoints in ZF2, I recommend using
<xhtml:code>Zend\Mvc\Controller\AbstractRestfulController</xhtml:code>. This
controller contains an <xhtml:code>options()</xhtml:code> method which you can
use to respond to an <xhtml:code>OPTIONS</xhtml:code> request. As with any ZF2
controller, returning a response object will prevent rendering and
bubble out immediately so that the response is returned.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
namespace My\Controller;
use Zend\Mvc\Controller\AbstractRestfulController;

class FooController extends AbstractRestfulController
{
    public function options()
    {
        $response = $this-&gt;getResponse();
        $headers  = $response-&gt;getHeaders();

        // If you want to vary based on whether this is a collection or an
        // individual item in that collection, check if an identifier from
        // the route is present
        if ($this-&gt;params()-&gt;fromRoute('id', false)) {
            // Allow viewing, partial updating, replacement, and deletion
            // on individual items
            $headers-&gt;addHeaderLine('Allow', implode(',', array(
                'GET',
                'PATCH',
                'PUT',
                'DELETE',
            )));
            return $response;
        }

        // Allow only retrieval and creation on collections
        $headers-&gt;addHeaderLine('Allow', implode(',', array(
            'GET',
            'POST',
        )));
        return $response;
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The next trick is returning the 405 response if an invalid
option is used. For this, you can create a listener in your
controller, and wire it to listen at higher-than-default priority.
As an example:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
namespace My\Controller;
use Zend\EventManager\EventManagerInterface;
use Zend\Mvc\Controller\AbstractRestfulController;

class FooController extends AbstractRestfulController
{
    protected $allowedCollectionMethods = array(
        'GET',
        'POST',
    );

    protected $allowedResourceMethods = array(
        'GET',
        'PATCH',
        'PUT',
        'DELETE',
    );

    public function setEventManager(EventManagerInterface $events)
    {
        parent::setEventManager($events);
        $events-&gt;attach('dispatch', array($this, 'checkOptions'), 10);
    }

    public function checkOptions($e)
    {
        $matches  = $e-&gt;getRouteMatch();
        $response = $e-&gt;getResponse();
        $request  = $e-&gt;getRequest();
        $method   = $request-&gt;getMethod();

        // test if we matched an individual resource, and then test
        // if we allow the particular request method
        if ($matches-&gt;getParam('id', false)) {
            if (!in_array($method, $this-&gt;allowedResourceMethods)) {
                $response-&gt;setStatusCode(405);
                return $response;
            }
            return;
        }

        // We matched a collection; test if we allow the particular request 
        // method
        if (!in_array($method, $this-&gt;allowedCollectionMethods)) {
            $response-&gt;setStatusCode(405);
            return $response;
        }
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Note that I moved the allowed methods into properties; if I did
the above, I'd refactor the <xhtml:code>options()</xhtml:code> method to use
those properties as well to ensure they are kept in sync.</xhtml:p>
<xhtml:p>Also note that in the case of an invalid method, I return a
response object. This ensures that nothing else needs to execute in
the controller; I discover the problem and return early.</xhtml:p>
<xhtml:h2>End-User Documentation</xhtml:h2>
<xhtml:p>Now that we have the technical solution out of the way, we're
still left with the bulk of the work left to accomplish: providing
end-user documentation detailing the various payloads, errors,
etc.</xhtml:p>
<xhtml:p>I've seen two compelling approaches to this problem. The first
builds on the <xhtml:code>OPTIONS</xhtml:code> method, and the other uses a
hypermedia link in every response to point to documentation.</xhtml:p>
<xhtml:p>The <xhtml:code>OPTIONS</xhtml:code> solution is this: <xhtml:a href="http://zacstewart.com/2012/04/14/http-options-method.html">use the
body of an <xhtml:code>OPTIONS</xhtml:code> response to provide
documentation</xhtml:a>. (Keith Casey <xhtml:a href="http://vimeo.com/49613738">gave an excellent short presentation
about this at REST Fest 2012</xhtml:a>).</xhtml:p>
<xhtml:p>The <xhtml:code>OPTIONS</xhtml:code> method allows for you to return a body
in the response, and also allows for content negotiation. The
theory, then, is that you return media-type-specific documentation
that details the methods allowed, and what they specifically accept
in the body. While there is no standard for this at this time, the
first article I linked suggested including a description, the
parameters expected, and one or more example request bodies for
each HTTP method allowed; you'd likely also want to detail the
responses that can be expected.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "POST": {
        "description": "Create a new status",
        "parameters": {
            "type": {
                "type": "string",
                "description": "Status type -- text, image, or url; defaults to text",
                "required": false
            },
            "text": {
                "type": "string",
                "description": "Status text; required for text types, optional for others",
                "required": false
            },
            "image_url": {
                "type": "string",
                "description": "URL of image for image types; required for image types",
                "required": false
            },
            "link_url": {
                "type": "string",
                "description": "URL of image for link types; required for link types",
                "required": false
            }
        },
        "responses": [
            {
                "describedBy": "http://example.com/problems/invalid-status",
                "title": "Submitted status was invalid",
                "detail": "Missing text field required for text type"
            },
            {
                "id": "abcdef123456",
                "type": "text",
                "text": "This is a status update",
                "timestamp": "2013-02-22T10:06:05+0:00"
            }
        ],
        "examples": [
            {
                "text": "This is a status update"
            },
            {
                "type": "image",
                "text": "This is the image caption",
                "image_url": "http://example.com/favicon.ico"
            },
            {
                "type": "link",
                "text": "This is a description of the link",
                "link_url": "http://example.com/"
            },
        ]
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>If you were to use this methodology, you would alter the
<xhtml:code>options()</xhtml:code> method such that it does not return a
response object, but instead return a view model with the
documentation.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
namespace My\Controller;
use Zend\Mvc\Controller\AbstractRestfulController;

class FooController extends AbstractRestfulController
{
    protected $viewModelMap = array(/* ... */);

    public function options()
    {
        $response = $this-&gt;getResponse();
        $headers  = $response-&gt;getHeaders();

        // Get a view model based on Accept types
        $model    = $this-&gt;acceptableViewModelSelector($this-&gt;viewModelMap);

        // If you want to vary based on whether this is a collection or an
        // individual item in that collection, check if an identifier from
        // the route is present
        if ($this-&gt;params()-&gt;fromRoute('id', false)) {
            // Still set the Allow header
            $headers-&gt;addHeaderLine('Allow', implode(
                ',', 
                $this-&gt;allowedResourceMethods
            ));

            // Set documentation specification as variables
            $model-&gt;setVariables($this-&gt;getResourceDocumentationSpec());
            return $model;
        }

        // Allow only retrieval and creation on collections
        $headers-&gt;addHeaderLine('Allow', implode(
            ',',
            $this-&gt;allowedCollectionMethods
        ));
        $model-&gt;setVariables($this-&gt;getCollectionDocumentationSpec());
        return $model;
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>I purposely didn't provide the implementations of the
<xhtml:code>getResourceDocumentationSpec()</xhtml:code> and
<xhtml:code>getCollectionDocumentationSpec()</xhtml:code> methods, as that will
likely be highly specific to your application. Another possibility
is to use your view engine for this, and specify a template file
that has the fully-populated information. This would require a
custom renderer when using JSON or XML, but is a pretty easy
solution.</xhtml:p>
<xhtml:p><xhtml:strong>However, there's one cautionary tale to tell</xhtml:strong>,
something I already mentioned: <xhtml:code>OPTIONS</xhtml:code>, per the
specification, is <xhtml:em>non-cacheable</xhtml:em>. What this means is that
everytime somebody makes an <xhtml:code>OPTIONS</xhtml:code> request, any cache
control headers you provide will be ignored, which means hitting
the server for each and every request to the documentation.
Considering documentation is static, this is problematic; it has
even prompted <xhtml:a href="http://www.mnot.net/blog/2012/10/29/NO_OPTIONS">blog posts urging
you not to use OPTIONS for documentation</xhtml:a>.</xhtml:p>
<xhtml:p>Which brings us to the second solution for end-user
documentation: a static page referenced via a hypermedia link.</xhtml:p>
<xhtml:p>This solution is insanely easy: you simply provide a
<xhtml:code>Link</xhtml:code> header in your response, and provide a
<xhtml:code>describedby</xhtml:code> reference pointing to the documentation
page:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
Link: &lt;http://example.com/api/documentation.md&gt;; rel="describedby"
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>With ZF2, this is trivially easy to accomplish: create a route
and endpoint for your documentation, and then a listener on your
controller that adds the <xhtml:code>Link</xhtml:code> header to your
response.</xhtml:p>
<xhtml:p>The latter, adding the link header, might look like this:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
namespace My\Controller;
use Zend\EventManager\EventManagerInterface;
use Zend\Mvc\Controller\AbstractRestfulController;

class FooController extends AbstractRestfulController
{
    public function setEventManager(EventManagerInterface $events)
    {
        parent::setEventManager($events);
        $events-&gt;attach('dispatch', array($this, 'injectLinkHeader'), 20);
    }

    public function injectLinkHeader($e)
    {
        $response = $e-&gt;getResponse();
        $headers  = $response-&gt;getHeaders();
        $headers-&gt;addHeaderLine('Link', sprintf(
            '</xhtml:code>
</xhtml:pre></xhtml:div>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[RESTful APIs with ZF2, Part 2]]></title>
    <published>2013-02-13T13:40:00+0000</published>
    <updated>2013-02-13T13:40:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2013-02-13-restful-apis-with-zf2-part-2.html"/>
    <id>http://mwop.net/blog/2013-02-13-restful-apis-with-zf2-part-2.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>In my <xhtml:a href="/blog/2013-02-11-restful-apis-with-zf2-part-1.html">last post</xhtml:a>,
I covered some background on REST and the Richardson Maturity
Model, and some emerging standards around hypermedia APIs in JSON;
in particular, I outlined aspects of Hypermedia Application
Language (HAL), and how it can be used to define a generic
structure for JSON resources.</xhtml:p>
<xhtml:p>In this post, I cover an aspect of RESTful APIs that's often
overlooked: reporting problems.</xhtml:p>
<xhtml:h2>Background</xhtml:h2>
<xhtml:p>APIs are useful when they're working. But when they fail,
they're only useful if they provide us with meaningful information;
if all I get is a status code, and no indication of what caused the
issue, or where I might look for more information, I get
frustrated.</xhtml:p>
<xhtml:p>In consuming APIs, I've come to the following conclusions:</xhtml:p>
<xhtml:ul>
<xhtml:li>Error conditions need to provide detailed information as to
what went wrong, and what steps I may be able to take next. An
error code with no context gives me nothing to go on.</xhtml:li>
<xhtml:li>Errors need to be reported consistently. Don't report the error
one way one time, and another way the next.</xhtml:li>
<xhtml:li><xhtml:strong>DO</xhtml:strong> use HTTP status codes to indicate an error
happened. Nothing is more irksome than getting back a 200 status
with an error payload.</xhtml:li>
<xhtml:li>Errors should be reported in a format I have indicated I will
Accept (as in the HTTP header). Perhaps the only think more irksome
than a 200 status code for an error is getting back an HTML page
when I expect JSON.</xhtml:li>
</xhtml:ul>
<xhtml:h2>Why Status Codes Aren't Enough</xhtml:h2>
<xhtml:p>Since REST leverages and builds on HTTP, an expedient solution
for reporting problems is to simply use <xhtml:a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">HTTP
status codes</xhtml:a>. These are well understood by web developers,
right?</xhtml:p>
<xhtml:p><xhtml:code>4xx</xhtml:code> error codes are errors made by the requestor,
and are actually fairly reasonable to use for reporting things such
as lack of authorization tokens, incomplete requests, unsupportable
operations, or non-supported media types.</xhtml:p>
<xhtml:p>But what happens when the error is on the server - because
something has gone wrong such as inability to reach your
persistence layer or credential storage? The <xhtml:code>5xx</xhtml:code>
series of status codes is sparse and wholly unsuited to reporting
errors of these types -- <xhtml:em>though you'll likely still want to use
a <xhtml:code>500</xhtml:code> status to report the failure</xhtml:em>. But what do
you present to the consumer so that they know whether or not to try
again, or what to report to you so that you can fix the issue?</xhtml:p>
<xhtml:p>A status code simply isn't enough information most of the time.
Yes, you want to define standard status codes so that your clients
can perform reasonable branching, but you also need a way to
communicate <xhtml:em>details</xhtml:em> to the end-user, so that they can log
the information for themselves, display information to their own
end-users, and/or report it back to you so you can do something to
resolve the situation.</xhtml:p>
<xhtml:h2>Custom Media Types</xhtml:h2>
<xhtml:p>The first step is to use a custom media type. Media types are
typically both a name as well as a structure -- and the latter is
what we're after when it comes to error reporting.</xhtml:p>
<xhtml:p>If we return a response using this media type, the client then
knows how to parse it, and can then process it, log it,
whatever.</xhtml:p>
<xhtml:p>Sure, you can make up your own format -- as long as you are
consistent in using it, and you document it. But personally, I
don't like inventing new formats when standard formats exist
already. Custom formats mean that custom clients are required for
working with the services; using a standard format can save effort
and time.</xhtml:p>
<xhtml:p>In the world of JSON, I've come across two error media types
that appear to be gaining traction:
<xhtml:code>application/api-problem+json</xhtml:code> and
<xhtml:code>application/vnd.error+json</xhtml:code></xhtml:p>
<xhtml:h3>API-Problem</xhtml:h3>
<xhtml:p>This particular media type is <xhtml:a href="http://tools.ietf.org/html/draft-nottingham-http-problem-02">via
the IETF</xhtml:a>. Like HAL, it provides formats in both JSON and XML,
making it a nice cross-platform choice.</xhtml:p>
<xhtml:p>As noted already, the media type is
<xhtml:code>application/api-problem+json</xhtml:code>. The representation is a
single resource, with the following properties:</xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:strong>describedBy</xhtml:strong>: a URL to a document describing
the error condition (required)</xhtml:li>
<xhtml:li><xhtml:strong>title</xhtml:strong>: a brief title for the error condition
(required)</xhtml:li>
<xhtml:li><xhtml:strong>httpStatus</xhtml:strong>: the HTTP status code for the
current request (optional)</xhtml:li>
<xhtml:li><xhtml:strong>detail</xhtml:strong>: error details specific to this request
(optional)</xhtml:li>
<xhtml:li><xhtml:strong>supportId</xhtml:strong>: a URL to the specific problem
occurrence (e.g., to a log message) (optional)</xhtml:li>
</xhtml:ul>
<xhtml:p>As an example:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
HTTP/1.1 500 Internal Error
Content-Type: application/api-problem+json

{
    "describedBy": "http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html",
    "detail": "Status failed validation",
    "httpStatus": 500,
    "title": "Internal Server Error"
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The specification allows a large amount of flexibility -- you
can have your own custom error types, so long as you have a
description of them to link to. You can provide as little or as
much detail as you want, and even decide what information to expose
based on environment.</xhtml:p>
<xhtml:p>I personally like to point to the HTTP status code definitions,
and then provide request-specific detail; I find this gives quick
and simple results that I can later shape as I add more detail to
my API. However, the specification definitely encourages you to
have unique error types with discrete URIs that describe them --
never a bad thing when creating APIs.</xhtml:p>
<xhtml:h3>vnd.error</xhtml:h3>
<xhtml:p>This is a <xhtml:a href="https://github.com/blongden/vnd.error">proposed media type</xhtml:a>
within the HAL community. Like HAL, it provides formats in both
JSON and XML, making it a nice cross-platform choice.</xhtml:p>
<xhtml:p>It differentiates from API-Problem in a few ways. First, it
allows, and even encourages, reporting collections of errors. If
you consider PHP exceptions and the fact that they support
"previous" exceptions, this is a powerful concept; you can report
the entire chain of errors that led to the response. Second, it
encourages pushing detail out of the web service; errors include a
"logRef" property that points to where the error detail lives. This
is probably better illustrated than explained.</xhtml:p>
<xhtml:p>The response payload is an array of objects. Each object has the
following members:</xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:strong>logRef</xhtml:strong>: a unique identifier for the specific
error which can then be used to identify the error within
server-side logs (required)</xhtml:li>
<xhtml:li><xhtml:strong>message</xhtml:strong>: the error message itself
(required)</xhtml:li>
<xhtml:li><xhtml:strong>_links</xhtml:strong>: HAL-compatible links. Typically,
"help", "describes", and/or "describedBy" relations will be defined
here.</xhtml:li>
</xhtml:ul>
<xhtml:p>As an example, let's consider the API-Problem example I had
earlier, and provide a vnd.error equivalent:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
HTTP/1.1 500 Internal Error
Content-Type: application/vnd.error+json

[
    {
        "logRef": "someSha1HashMostLikely",
        "message": "Status failed validation",
        "_links": {
            "describedBy": {"href": "http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html"}
        }
    }
]
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>vnd.error basically begs you to create custom error types, with
documentation end-points that detail the source of the error and
what you can do about it (this is true of API-Problem as well).</xhtml:p>
<xhtml:p>The requirement to include a log reference ("logRef") and have
it be unique can be a stumbling block to implementation, however,
as it requires effort for uniquely identifying requests, and
logging. However, both the identification and logging can be
automated.</xhtml:p>
<xhtml:h2>Summary</xhtml:h2>
<xhtml:p>Error reporting in APIs is as important as the normal resource
payloads themselves. Without good error reporting, when an API
raises errors, clients have difficulty understanding what they can
do next, and cannot provide you, the API provider, with information
that will allow you to debug on the server side.</xhtml:p>
<xhtml:p>As noted at the beginning of the article, if you follow the
rules below, you'll make consumers of your API happier and more
productive.</xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:strong>DO</xhtml:strong> use appropriate HTTP status codes to
indicate an error happened.</xhtml:li>
<xhtml:li>Report errors in a format I have indicated I will Accept (as in
the HTTP header).</xhtml:li>
<xhtml:li>Report errors consistently. Don't report the error one way one
time, and another way the next. Standardize on a specific
error-reporting media type . While you <xhtml:em>can</xhtml:em> create your own
error structure, I recommend using documented, accepted standards.
This will make clients more re-usable, and make many of your
decisions for you.</xhtml:li>
<xhtml:li>Provide detailed information as to what went wrong, and what
steps I may be able to take next. Provide documentation for each
type of error, and link to that documentation from your error
payloads.</xhtml:li>
</xhtml:ul>
<xhtml:p>Which brings me to...</xhtml:p>
<xhtml:h2>Next time</xhtml:h2>
<xhtml:p>I realize I still haven't covered anything specific to ZF2, but
I'll start next time, when I cover the next topic: documenting your
API. An undocumented API is a useless API, so it's good to start
baking documentation in immediately. I'll survey some of the
possibilities and how they can be implemented in ZF2 in the next
installment, and then we can get our hands dirty with actual API
development.</xhtml:p>
<xhtml:h3>Updates</xhtml:h3>
<xhtml:p><xhtml:em>Note: I'll update this post with links to the other posts in
the series as I publish them.</xhtml:em></xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:a href="/blog/2013-02-11-restful-apis-with-zf2-part-1">Part
1</xhtml:a></xhtml:li>
<xhtml:li><xhtml:a href="/blog/2013-02-25-restful-apis-with-zf2-part-3">Part
3</xhtml:a></xhtml:li>
</xhtml:ul>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[RESTful APIs with ZF2, Part 1]]></title>
    <published>2013-02-12T11:42:00+0000</published>
    <updated>2013-02-13T13:40:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2013-02-11-restful-apis-with-zf2-part-1.html"/>
    <id>http://mwop.net/blog/2013-02-11-restful-apis-with-zf2-part-1.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>RESTful APIs have been an interest of mine for a couple of
years, but due to <xhtml:a href="http://framework.zend.com/blog//zend-framework-2-0-0-stable-released.html">
circumstances</xhtml:a>, I've not had much chance to work with them in
any meaningful fashion until recently.</xhtml:p>
<xhtml:p><xhtml:a href="http://akrabat.com/">Rob Allen</xhtml:a> and I proposed a
workshop for <xhtml:a href="http://conference.phpbenelux.eu/2013/">PHP
Benelux 2013</xhtml:a> covering RESTful APIs with ZF2. When it was
accepted, it gave me the perfect opportunity to dive in and start
putting the various pieces together.</xhtml:p>
<xhtml:h2>Background</xhtml:h2>
<xhtml:p>I've attended any number of conference sessions on API design,
read countless articles, and engaged in quite a number of
conversations. Three facts keep cropping up:</xhtml:p>
<xhtml:ol>
<xhtml:li>JSON is fast becoming the preferred exchange format due to the
ease with which it de/serializes in almost every language.</xhtml:li>
<xhtml:li>The "holy grail" is <xhtml:a href="http://martinfowler.com/articles/richardsonMaturityModel.html">Richardson
Maturity Model</xhtml:a> Level 3.</xhtml:li>
<xhtml:li>It's really hard to achieve RMM level 3 with JSON.</xhtml:li>
</xhtml:ol>
<xhtml:h3>Richardson Maturity Model</xhtml:h3>
<xhtml:p>As a quick review, the Richardson Maturity Model has the
following 4 levels:</xhtml:p>
<xhtml:ul>
<xhtml:li>Level 0: "The swamp of POX." Basically, a service that uses TCP
for transport, primarily as a form of remote procedure call (RPC).
Typically, these are not really leveraging HTTP in any meaningful
fashion; most systems will use HTTP POST for all interactions.
Also, you will often have a single endpoint for all interactions,
regardless of whether or not they are strictly related. XML-RPC,
SOAP, and JSON-RPC fall under this category.</xhtml:li>
<xhtml:li>Level 1: "Resources." In these services, you start breaking the
service into multiple services, one per "resource," or, in object
oriented terms, per object. This means a distinct URL per object,
which means each has its own distinct identity on the web; this
often extends not only to the collection of objects, but to
individual objects under the collection as well (e.g., "/books" as
well as "/books/life-of-pi"). The service may still be RPC in
nature, however, and, at this level, often is still using a single
HTTP method for all interactions with the resource.</xhtml:li>
<xhtml:li>Level 2: "HTTP Verbs." At this level, we start using HTTP verbs
with our services in the way the HTTP specification intends. GET is
for safe operations, and should be cacheable; POST is used for
creation and/or updating; DELETE can be used to delete a resource;
etc. Rather than doing RPC style methods, we leverage HTTP,
occasionally passing additional parameters via the query string or
request body. Considerations such as HTTP caching and idempotence
are taken into account.</xhtml:li>
<xhtml:li>Level 3: "Hypermedia Controls." Building on the previous level,
our resource representations now also include <xhtml:em>links</xhtml:em>, which
indicate what we can <xhtml:em>do next</xhtml:em>. At this level, our API
becomes practically self-describing; given a single end-point, we
should be able to start crawling it, using the links in a
representation to lead us to the next actions.</xhtml:li>
</xhtml:ul>
<xhtml:p>When I first started playing with web services around a decade
ago, everything was stuck at Level 0 or Level 1 -- usually with
Level 1 users downgrading to Level 0 because Level 0 offerred
consistency and predictability if you chose to use a service type
that had a defined envelope format (such as XML-RPC or SOAP). (I
even wrote the XML-RPC server implementation for Zend Framework
because I got sick of writing one-off parsers/serializers for
custom XML web service implementations. When you're implementing
many services, predictability is a huge win.)</xhtml:p>
<xhtml:p>A few years ago, I started seeing a trend towards Level 2. Web
developers like the simplicity of using HTTP verbs, as they map
very well to <xhtml:a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</xhtml:a>
operations -- the bread and butter of web development. Couple this
concept with JSON, and it becomes trivially simple to both create a
web service, as well as consume it.</xhtml:p>
<xhtml:p><xhtml:em>I'd argue that the majority of web developers are quite
happy to be at Level 2 -- and have no problem staying there.
They're productive, and the concepts are easy -- both to understand
and to implement.</xhtml:em></xhtml:p>
<xhtml:p>Level 3, though, is where it becomes really interesting. The
idea that I can examine the represention <xhtml:em>alone</xhtml:em> in order to
understand what I can do next is very intriguing and
empowering.</xhtml:p>
<xhtml:h3>JSON and Hypermedia</xhtml:h3>
<xhtml:p>With XML, hypermedia basically comes for free. Add some
&lt;link&gt; elements to your representation, and you're done --
and don't forget the link <xhtml:code>rel</xhtml:code>ations!</xhtml:p>
<xhtml:p>JSON, however, is another story.</xhtml:p>
<xhtml:p>Where do the links go? <xhtml:em>There is no single, defined way to
represent a hyperlink in JSON.</xhtml:em></xhtml:p>
<xhtml:p>Fortunately, there are some emerging standards.</xhtml:p>
<xhtml:p>First is use of the <xhtml:a href="http://www.w3.org/wiki/LinkHeader">"Link" HTTP header</xhtml:a>. While
the page I linked shows only a single link in the header, you can
have multiple links separated by commas. GitHub uses this when
providing pagination links in their API. Critics will point out
that the HTTP headers are not technically part of the
representation, however; strict interpetations of REST and RMM
indicate that the hypermedia links should be part of the resource
representation. Regardless, having the links in the HTTP headers is
useful for pre-traversal of a service, as you can perform HEAD
requests only to discover possible actions and workflows.</xhtml:p>
<xhtml:p><xhtml:a href="http://amundsen.com/media-types/collection/format/">Collection+JSON</xhtml:a>
is interesting, as it describes the entire JSON envelope. My one
criticism is that it details too much; whenever I see a format that
dictates how to describe types, I think of XML-RPC or SOAP, and get
a little twitchy. It's definitely worth a look, though.</xhtml:p>
<xhtml:p>What's captured my attention of late, however, is <xhtml:a href="http://stateless.co/hal_specification.html">Hypertext Application
Language</xhtml:a>, or HAL for short. HAL has very few rules, but
succinctly describes both how to provide hypermedia in JSON as well
as how to represent embedded resources - the two things that most
need standardized structure in JSON. It does this while still
providing a generic media type, and also describing a mirror image
XML format!</xhtml:p>
<xhtml:h3>HAL Media Types</xhtml:h3>
<xhtml:p>HAL defines two generic media types:
<xhtml:code>application/hal+xml</xhtml:code> and
<xhtml:code>application/hal+json</xhtml:code>. You will use these as the
response Content-Type, as they describe the response
representation; the client can simply request
<xhtml:code>application/json</xhtml:code>, and the response format remains
compatible.</xhtml:p>
<xhtml:h3>HAL and Links</xhtml:h3>
<xhtml:p>HAL provides a very simple structure for JSON hypermedia links.
First, all resource representations must contain hypermedia links,
and all links are provided in a "_links" object:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Second, links are properties of this object. The property name
is the link relation, and the value is an object containing
minimally an "href" property.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status/1234"}
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>If a given relation can have multiple links, you provide instead
an array of objects:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status/1234"},
        "conversation": [
            {"href": "http://example.com/api/status/1237"},
            {"href": "http://example.com/api/status/1241"}
        ]
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Individual links can contain other attributes as desired -- I've
seen people include the relation again so that it's self-contained
in the link object, and it's not uncommon to include a title or
name.</xhtml:p>
<xhtml:h3>HAL and Resources</xhtml:h3>
<xhtml:p>HAL imposes no structure over resources other than requiring the
hypermedia links; even then, you typically do not include the
hypermedia links when making a request of the web service; the
hypermedia links are included only in the representations
<xhtml:em>returned</xhtml:em> by the service.</xhtml:p>
<xhtml:p>So, as an example, you would POST the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
POST /api/status
Host: example.com
Accept: application/json
Content-Type: application/json

{
    "status": "This is my awesome status update!",
    "user": "mwop"
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>And from that request, you'd receive the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
201 Created
Location: http://example.com/api/status/1347
Content-Type: application/hal+json

{
    "_links": {
        "self": {"href": "http://example.com/api/status/1347"}
    },
    "id": "1347",
    "timestamp": "2013-02-11 23:33:47",
    "status": "This is my awesome status update!",
    "user": "mwop"
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:h3>HAL and Embedded Resources</xhtml:h3>
<xhtml:p>The other important thing that HAL defines is how to
<xhtml:em>embed</xhtml:em> resources. Why is this important? If the resource
references other resources, you will want to be able to link to
them so you can perform operations on them, too.</xhtml:p>
<xhtml:p>Embedded resources are represented inside an "_embedded" object
of the representation, and, as resources, contain their own
"_links" object as well. Each resource you embed is assigned to a
property of that object, and if multiple objects of the same type
are returned, an array of resources is assigned. In fact, this
latter is how you represent <xhtml:em>collections</xhtml:em> in HAL.</xhtml:p>
<xhtml:p>Let's consider a simple example first. In previous code samples,
I have a "user" that's a string; let's make that an embedded
resource instead.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status/1347"}
    },
    "id": "1347",
    "timestamp": "2013-02-11 23:33:47",
    "status": "This is my awesome status update!",
    "_embedded": {
        "user": {
            "_links": {
                "self": {"href": "http://example.com/api/user/mwop"}
            }
            "id": "mwop",
            "name": "Matthew Weier O'Phinney",
            "url": "http://mwop.net"
        }
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>I've moved the "user" out of the representation, and into the
"_embedded" object -- because this is where you define embedded
resources. Note that the "user" is a standard HAL resource itself
-- containing hypermedia links.</xhtml:p>
<xhtml:p>Now let's look at a collection:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status"},
        "next": {"href": "http://example.com/api/status?page=2"},
        "last": {"href": "http://example.com/api/status?page=100"}
    },
    "count": 2973,
    "per_page": 30,
    "page": 1,
    "_embedded": {
        "status": [
            {
                "_links": {
                    "self": {"href": "http://example.com/api/status/1347"}
                },
                "id": "1347",
                "timestamp": "2013-02-11 23:33:47",
                "status": "This is my awesome status update!",
                "_embedded": {
                    "user": {
                        "_links": {
                            "self": {"href": "http://example.com/api/user/mwop"}
                        }
                        "id": "mwop",
                        "name": "Matthew Weier O'Phinney",
                        "url": "http://mwop.net"
                    }
                }
            }
            /* ... */
        ]
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Note that the "status" property is an array; semantically, all
resources under this key are of the same type. Also note that the
parent resource has some additional link relations -- these are
related to pagination, and allow a client to determine what the
next and last pages are (and, if we were midway into the
collection, previous and first pages). Since the collection is also
a resource, it has some interesting metadata -- how many resources
are in the collection, how many we represent per page, and what the
current page is.</xhtml:p>
<xhtml:p>Also note that you can nest resources -- simply include an
"_embedded" object inside an embedded resource, with additional
resources, as I've done with the "user" resource inside the status
resource shown here. It's turtles all the way down.</xhtml:p>
<xhtml:h2>Next Time</xhtml:h2>
<xhtml:p>The title of this post indicates I'll be talking about building
RESTful APIs with ZF2 -- but so far, I've not said anything about
ZF2.</xhtml:p>
<xhtml:p>I'll get there. But there's another detour to take: reporting
errors.</xhtml:p>
<xhtml:h3>Updates</xhtml:h3>
<xhtml:p><xhtml:em>Note: I'll update this post with links to the other posts in
the series as I publish them.</xhtml:em></xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:a href="/blog/2013-02-13-restful-apis-with-zf2-part-2">Part
2</xhtml:a></xhtml:li>
<xhtml:li><xhtml:a href="/blog/2013-02-25-restful-apis-with-zf2-part-3">Part
3</xhtml:a></xhtml:li>
</xhtml:ul>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Responding to Different Content Types in RESTful ZF Apps]]></title>
    <published>2010-03-04T20:28:07+0000</published>
    <updated>2010-03-10T14:28:22+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/233-Responding-to-Different-Content-Types-in-RESTful-ZF-Apps.html"/>
    <id>http://mwop.net/blog/233-Responding-to-Different-Content-Types-in-RESTful-ZF-Apps.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>In <xhtml:a href="/matthew/archives/227-Exposing-Service-APIs-via-Zend-Framework.html">
previous</xhtml:a> <xhtml:a href="/matthew/archives/228-Building-RESTful-Services-with-Zend-Framework.html">
articles</xhtml:a>, I've explored building service endpoints and RESTful
services with Zend Framework. With RPC-style services, you get to
cheat: the protocol dictates the content type (XML-RPC uses XML,
JSON-RPC uses JSON, SOAP uses XML, etc.). With REST, however, you
have to make choices: what serialization format will you
support?</xhtml:p>
<xhtml:p>Why not support multiple formats?</xhtml:p>
<xhtml:p>There's no reason you can't re-use your RESTful web service to
support multiple formats. Zend Framework and PHP have plenty of
tools to assist you in responding to different format requests, so
don't limit yourself. With a small amount of work, you can make
your controllers format agnostic, and ensure that you respond
appropriately to different requests.</xhtml:p>
<xhtml:h2>Content-Type Detection</xhtml:h2>
<xhtml:p>The first problem to solve is going to be how to retrieve passed
parameters. When using XML or JSON as your serialization format,
you aren't getting your standard POST variables -- you're getting a
raw post instead, and you'll need to deserialize the payload. In
fact, if you're getting a PUT request, you also have some work to
do, as PHP doesn't do anything with PUT requests.</xhtml:p>
<xhtml:p>I do this via an action helper. The basic algorithm is:</xhtml:p>
<xhtml:ul>
<xhtml:li>Do we have a raw body in the request? If not, nothing more need
be done.</xhtml:li>
<xhtml:li>Determine the Content-Type passed in the request headers, and
decode appropriately:
<xhtml:ul>
<xhtml:li>If it was JSON, pass the raw request body to
<xhtml:code>json_decode</xhtml:code> or <xhtml:code>Zend_Json::decode</xhtml:code>.</xhtml:li>
<xhtml:li>If it was XML, I pass the raw request body to the
<xhtml:code>Zend_Config_XML</xhtml:code> constructor, and then serialize to an
arrya using the <xhtml:code>toArray()</xhtml:code> method. Yes, it's a hack,
but it's effective.</xhtml:li>
<xhtml:li>Otherwise, I assume I've got a regular PUT-style request, and I
pass the data to <xhtml:code>parse_str()</xhtml:code>.</xhtml:li>
</xhtml:ul>
</xhtml:li>
</xhtml:ul>
<xhtml:p>I keep the values within the action helper, and then retrieve
them on demand within my action controller. The helper looks like
the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Scrummer_Controller_Helper_Params 
    extends Zend_Controller_Action_Helper_Abstract
{
    /**
     * @var array Parameters detected in raw content body
     */
    protected $_bodyParams = array();

    /**
     * Do detection of content type, and retrieve parameters from raw body if 
     * present
     * 
     * @return void
     */
    public function init()
    {
        $request     = $this-&gt;getRequest();
        $contentType = $request-&gt;getHeader('Content-Type');
        $rawBody     = $request-&gt;getRawBody();
        if (!$rawBody) {
            return;
        }
        switch (true) {
            case (strstr($contentType, 'application/json')):
                $this-&gt;setBodyParams(Zend_Json::decode($rawBody));
                break;
            case (strstr($contentType, 'application/xml')):
                $config = new Zend_Config_Xml($rawBody);
                $this-&gt;setBodyParams($config-&gt;toArray());
                break;
            default:
                if ($request-&gt;isPut()) {
                    parse_str($rawBody, $params);
                    $this-&gt;setBodyParams($params);
                }
                break;
        }
    }

    /**
     * Set body params
     * 
     * @param  array $params 
     * @return Scrummer_Controller_Action
     */
    public function setBodyParams(array $params)
    {
        $this-&gt;_bodyParams = $params;
        return $this;
    }

    /**
     * Retrieve body parameters
     * 
     * @return array
     */
    public function getBodyParams()
    {
        return $this-&gt;_bodyParams;
    }

    /**
     * Get body parameter
     * 
     * @param  string $name 
     * @return mixed
     */
    public function getBodyParam($name)
    {
        if ($this-&gt;hasBodyParam($name)) {
            return $this-&gt;_bodyParams[$name];
        }
        return null;
    }

    /**
     * Is the given body parameter set?
     * 
     * @param  string $name 
     * @return bool
     */
    public function hasBodyParam($name)
    {
        if (isset($this-&gt;_bodyParams[$name])) {
            return true;
        }
        return false;
    }

    /**
     * Do we have any body parameters?
     * 
     * @return bool
     */
    public function hasBodyParams()
    {
        if (!empty($this-&gt;_bodyParams)) {
            return true;
        }
        return false;
    }

    /**
     * Get submit parameters
     * 
     * @return array
     */
    public function getSubmitParams()
    {
        if ($this-&gt;hasBodyParams()) {
            return $this-&gt;getBodyParams();
        }
        return $this-&gt;getRequest()-&gt;getPost();
    }

    public function direct()
    {
        return $this-&gt;getSubmitParams();
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>This helper is intended to be run on each request, so I register
it in my bootstrap:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Bootstrap extends Zend_Application_Bootstrap_Bootstrap
{
    // ...
    protected function _initActionHelpers()
    {
        // ...
        $params = new Scrummer_Controller_Helper_Params();
        Zend_Controller_Action_HelperBroker::addHelper($params);
        // ...
    }
    // ...
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Within your action controller, all you need to do is call the
helper:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
$data = $this-&gt;params();
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>In a RESTful controller, you'll only need to use this with your
<xhtml:code>postAction</xhtml:code> and <xhtml:code>putAction</xhtml:code>. The beauty is
that your controller can remain ignorant of the Content-Type -- you
write the same logic to retrieve your parameters regardless.</xhtml:p>
<xhtml:h2>Responding to the client: Context Switching</xhtml:h2>
<xhtml:p>So, the first half of the problem is taken care of: how to
handle the request. The second half is responding
appropriately.</xhtml:p>
<xhtml:p>Zend Framework has some built in tooling to help with this. The
ContextSwitch and AjaxContext action helpers look for a particular
parameter -- "format" by default -- and, if detected, will render
an alternate view script named after the context. As an example, if
an "XML" context is detected, it will render
"&lt;controller&gt;/&lt;action&gt;.xml.phtml" -- note the ".xml"
segment of the script name.</xhtml:p>
<xhtml:p>Both helpers work in the same basic way (the latter,
AjaxContext, will only activate if the request is determined to
originate from an XMLHttpRequest): you define which actions in the
controller are context sensitive, and then if the context is
detected, a new view script will be used.</xhtml:p>
<xhtml:p>So, the first trick is ensuring that the context is passed. As
mentioned before, the helpers look for a "format" parameter in the
request object. You can pass this using a query parameter --
"?format=xml" -- but I find that ugly. There's an HTTP header
defined for this purpose already: "Accept".</xhtml:p>
<xhtml:p>Detecting the header and injecting the context into the request
is absurdly simple, and can be done in a
<xhtml:code>dispatchLoopStartup</xhtml:code> plugin:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Scrummer_Controller_Plugin_AcceptHandler
    extends Zend_Controller_Plugin_Abstract
{
    public function dispatchLoopStartup(Zend_Controller_Request_Abstract $request)
    {
        if (!$request instanceof Zend_Controller_Request_Http) {
            return;
        }

        $header = $request-&gt;getHeader('Accept');
        switch (true) {
            case (strstr($header, 'application/json')):
                $request-&gt;setParam('format', 'json');
                break;
            case (strstr($header, 'application/xml') 
                  &amp;&amp; (!strstr($header, 'html'))):
                $request-&gt;setParam('format', 'xml');
                break;
            default:
                break;
        }
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The above can be registered in your application
configuration:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="ini" xml:lang="ini">
resources.frontController.plugins[] = \"Scrummer_Controller_Plugin_AcceptHandler\"
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>I like my RESTful controllers to automatically expose their
methods as context-aware. To make this happen, I defined a marker
interface, "Scrummer_Rest_Controller", and created an action helper
that checks if the current controller implements it; if it does, I
then automatically add contexts for the RESTful actions.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Scrummer_Controller_Helper_RestContexts
    extends Zend_Controller_Action_Helper_Abstract
{
    protected $_contexts = array(
        'xml', 
        'json',
    );

    public function preDispatch()
    {
        $controller = $this-&gt;getActionController();
        if (!$controller instanceof Scrummer_Rest_Controller) {
            return;
        }

        $this-&gt;_initContexts();

        // Set a Vary response header based on the Accept header
        $this-&gt;getResponse()-&gt;setHeader('Vary', 'Accept');
    }

    protected function _initContexts()
    {
        $cs = $this-&gt;getActionController()-&gt;contextSwitch;
        $cs-&gt;setAutoJsonSerialization(false);
        foreach ($this-&gt;_contexts as $context) {
            foreach (array('index', 'post', 'get', 'put', 'delete') as $action) {
                $cs-&gt;addActionContext($action, $context);
            }
        }
        $cs-&gt;initContext();
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Register this via the bootstrap as well:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Bootstrap extends Zend_Application_Bootstrap_Bootstrap
{
    // ...
    protected function _initActionHelpers()
    {
        // ...
        $params = new Scrummer_Controller_Helper_Params();
        Zend_Controller_Action_HelperBroker::addHelper($params);

        $contexts = new Scrummer_Controller_Helper_RestContexts();
        Zend_Controller_Action_HelperBroker::addHelper($contexts);
        // ...
    }
    // ...
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>There are two things to note about this helper. First, you'll
see that I specify a "Vary" header. This is to ensure that if the
client chooses to cache responses, it will cache separate responses
based on the value sent in the "Accept" header.</xhtml:p>
<xhtml:p>Second, note that I turn off automatic JSON serialization in the
ContextSwitch helper. I do this so that I can keep my controller
context agnostic; this will require additional view scripts, but
the ability to keep my controller logic simple will be worth it.
More on that in a moment.</xhtml:p>
<xhtml:p>We now have the infrastructure in place to respond to different
contexts based on the "Accept" header, and can retrieve parameters
appropriately based on the "Content-Type" provided us. Now comes
the actual response.</xhtml:p>
<xhtml:h2>Responding to the client: Views</xhtml:h2>
<xhtml:p>Recall that ContextSwitch will attach an additional prefix to
the specified view script --
"&lt;controller&gt;/&lt;action&gt;.phtml" will become
"&lt;controller&gt;/&lt;action&gt;.xml.phtml" or
"&lt;controller&gt;/&lt;action&gt;.json.phtml". Basically, for each
context we will respond to, we have an additional view script per
action.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="text" xml:lang="text">
views/
|-- scripts/
|   `-- foo/
|      |-- delete.phtml
|      |-- delete.json.phtml
|      |-- delete.xml.phtml
|      |-- get.phtml
|      |-- get.json.phtml
|      |-- get.xml.phtml
|      |-- index.phtml
|      |-- index.json.phtml
|      |-- index.xml.phtml
|      |-- post.phtml
|      |-- post.json.phtml
|      |-- post.xml.phtml
|      |-- put.phtml
|      |-- put.json.phtml
|      `-- put.xml.phtml
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>This may seem like overkill, but consider the following
representative method from my controller:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
    public function postAction()
    {
        $data    = $this-&gt;params();
        $service = $this-&gt;getService();
        $result  = $service-&gt;add($data);  
        if (!$result) {
            $this-&gt;view-&gt;form = $service-&gt;getBacklogForm();
            return;
        }

        $this-&gt;view-&gt;success = true;
        $this-&gt;view-&gt;backlog = $result;
    }
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>You don't see anything in there about headers, redirects, or XHR
requests. Just slinging data to services and views. Real
simple.</xhtml:p>
<xhtml:p>The view scripts then take care of the appropriate display
logic. Let's look at two view scripts for the above action, one for
plain old HTML, the other for a JSON response:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
&lt;?php // backlog/post.phtml ?&gt;
&lt;?php 
if ($this-&gt;success):
    $this-&gt;response-&gt;setRedirect($this-&gt;url(array(
        'controller' =&gt; 'backlog',
        'id'         =&gt; $this-&gt;backlog-&gt;id,
    ), 'rest', true));
else: ?&gt;
&lt;h2&gt;Create new backlog&lt;/h2&gt;
&lt;?php
    $this-&gt;form-&gt;setAction($this-&gt;url())
               -&gt;setMethod('post');
    echo $this-&gt;form;
endif ?&gt;

&lt;?php // backlog/post.json.phtml ?&gt;
&lt;?php
if ($this-&gt;success) {
    $url = $this-&gt;url(array(
        'controller' =&gt; 'backlog',
        'id'         =&gt; $this-&gt;backlog-&gt;id,
    ), 'rest', true);
    $this-&gt;response-&gt;setHeader('Location', $url)
                   -&gt;setHttpResponseCode(201);
    echo $this-&gt;json($this-&gt;backlog-&gt;toArray());
    return;
}

$form = $this-&gt;form;
$form-&gt;setAction($this-&gt;url())
     -&gt;setMethod('post');
echo $this-&gt;jsonFormErrors($form);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>A few things to note: I inject my response object into the view.
I feel HTTP headers are part of the view, and thus I deal with them
there. That also serves the purpose of keeping my controllers thin
and agnostic. Additionally, you'll note that I use different
response codes for HTML versus JSON -- this allows my JSON-REST
support to be RESTful, by returning a 201 status code indicating
the resource was created; I also return a JSON representation of
the object. Finally, you'll note that I have a special view helper
for creating JSON representations of validation errors.</xhtml:p>
<xhtml:h2>Closing points</xhtml:h2>
<xhtml:p>This post is far from exhaustive, and I expect it will likely
raise at least as many questions as it tries to answer.</xhtml:p>
<xhtml:p>My main point in this article is to get you, the reader and
developer, thinking creatively about how to expose RESTful web
services. Hopefully, you're taking the following away:</xhtml:p>
<xhtml:ol>
<xhtml:li>Architect in such a way as to minimize the code in your
controllers; keep that code as agnostic as possible in regards to
where input comes from and what type of response is required.</xhtml:li>
<xhtml:li>Use front controller plugins and action helpers to create
scaffolding for your services; these are incredibly flexible and
re-usable, and help make point 1 that much easier.</xhtml:li>
<xhtml:li>Offload as much as possible to your views. This will allow you
to isolate logic specific to given formats.</xhtml:li>
</xhtml:ol>
<xhtml:p>What are you waiting for? Don't you have an API to expose?</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Building RESTful Services with Zend Framework]]></title>
    <published>2009-11-09T14:00:00+0000</published>
    <updated>2009-11-11T15:38:41+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/228-Building-RESTful-Services-with-Zend-Framework.html"/>
    <id>http://mwop.net/blog/228-Building-RESTful-Services-with-Zend-Framework.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>As a followup to my <xhtml:a href="/matthew/archives/227-Exposing-Service-APIs-via-Zend-Framework.html">
previous post</xhtml:a>, I now turn to RESTful web services. I originally
encountered the term when attending php|tropics in 2005, where
<xhtml:a href="http://twitter.com/g_schlossnagle">George
Schlossnaggle</xhtml:a> likened it to simple GET and POST requests. Since
then, the architectural style -- and developer understanding of the
architectural style -- has improved a bit, and a more solid
definition can be made.</xhtml:p>
<xhtml:p>At its heart, <xhtml:a href="http://en.wikipedia.org/wiki/Representational_State_Transfer"/>REST
simply dictates that a given resource have a unique address, and
that you interact with that resource using HTTP verbs. The standard
verbs utilized are:</xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:em>GET</xhtml:em>: retrieve a list of resources, or, if an
identifier is present, view a single resource</xhtml:li>
<xhtml:li><xhtml:em>POST</xhtml:em>: create a new resource with the data provided in
the POST</xhtml:li>
<xhtml:li><xhtml:em>PUT</xhtml:em>: update an existing resource as specified by an
identifier, using the PUT data</xhtml:li>
<xhtml:li><xhtml:em>DELETE</xhtml:em>: delete an existing resource as specified by an
identifier</xhtml:li>
</xhtml:ul>
<xhtml:p>The standard URL structure used is as follows:</xhtml:p>
<xhtml:ul>
<xhtml:li>"/resource" - GET (list) and POST operations</xhtml:li>
<xhtml:li>"/resource/{identifier}" - GET (view), PUT, and DELETE
operations</xhtml:li>
</xhtml:ul>
<xhtml:p>What the REST paradigm provides you is a simple, standard way to
structure your CRUD (Create-Read-Update-Delete) applications. Due
to the large number of REST clients available, it also means that
if you follow the rules, you get a ton of interoperability with
those clients.</xhtml:p>
<xhtml:p>As of <xhtml:a href="http://framework.zend.com/">Zend Framework</xhtml:a>
1.9.0, it's trivially easy to create RESTful routes for your MVC
application, as well as to handle the various REST actions via
action controllers.</xhtml:p>
<xhtml:p><xhtml:a href="http://framework.zend.com/manual/en/zend.controller.router.html#zend.controller.router.routes.rest">
Zend_Rest_Route</xhtml:a> allows you to define RESTful controllers at
several levels:</xhtml:p>
<xhtml:ul>
<xhtml:li>You can make it the default route, meaning that unless you have
additional routes, all controllers will be considered REST
controllers.</xhtml:li>
<xhtml:li>You can specify modules that contain RESTful controllers.</xhtml:li>
<xhtml:li>You can specify specific controllers per module that are
RESTful</xhtml:li>
</xhtml:ul>
<xhtml:p>As examples:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
$front = Zend_Controller_Front::getInstance();
$router = $front-&gt;getRouter();

// Specifying all controllers as RESTful:
$restRoute = new Zend_Rest_Route($front);
$router-&gt;addRoute('default', $restRoute);

// Specifying the \"api\" module only as RESTful:
$restRoute = new Zend_Rest_Route($front, array(), array(
    'api',
));
$router-&gt;addRoute('rest', $restRoute);

// Specifying the \"api\" module as RESTful, and the \"task\" controller of the
// \"backlog\" module as RESTful:
$restRoute = new Zend_Rest_Route($front, array(), array(
    'api',
    'backlog' =&gt; array('task'),
));
$router-&gt;addRoute('rest', $restRoute);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>To define a RESTful action controller, you can either extend
Zend_Rest_Controller, or simply define the following methods in a
standard controller extending Zend_Controller_Action (you'll need
to define them regardless):</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
// Or extend Zend_Rest_Controller
class RestController extends Zend_Controller_Action
{
    // Handle GET and return a list of resources
    public function indexAction() {}

    // Handle GET and return a specific resource item
    public function getAction() {}

    // Handle POST requests to create a new resource item
    public function postAction() {}

    // Handle PUT requests to update a specific resource item
    public function putAction() {}

    // Handle DELETE requests to delete a specific item
    public function deleteAction() {}
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>For those methods that operate on individual resources
(getAction(), putAction(), and deleteAction()), you can test for
the identifier using the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
if (!$id = $this-&gt;_getParam('id', false)) {
    // report error, redirect, etc.
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:h2>Responding is an art</xhtml:h2>
<xhtml:p>Many developers are either unaware of or ignore the part of the
specification that dictates what the <xhtml:em>response</xhtml:em> should look
like.</xhtml:p>
<xhtml:p>For instance, in classic REST, after performing a POST to create
a new item, you should do the following:</xhtml:p>
<xhtml:ul>
<xhtml:li>Set the HTTP response code to 201, indicating "Created"</xhtml:li>
<xhtml:li>Set the Location header to point to the canonical URI for the
newly created item: "/team/31"</xhtml:li>
<xhtml:li>Provide a representation of the newly created item</xhtml:li>
</xhtml:ul>
<xhtml:p>Note that there's no redirect, which flies in the face of
standard web development (where GET-POST-Redirect is the typical
format). This is a common "gotcha" moment.</xhtml:p>
<xhtml:p>Similarly, with PUT requests, you simply indicate an HTTP 200
status when successful, and show a representation of the updated
item. DELETE requests should return an HTTP 204 status (indicating
success - no content), with no body content.</xhtml:p>
<xhtml:p><xhtml:em>Note: when building RESTful HTML applications, you may want
to still do GET-POST-Redirect to prevent caching issues. The above
applies to RESTful web services, which typically use XML or JSON
for transactions, and have smart clients for interacting with the
service.</xhtml:em></xhtml:p>
<xhtml:p>I'll be writing another article soon showing some tips and
tricks for interacting with HTTP headers, both from the request and
for the response, as it's a subject lengthy enough for a post of
its own. In the meantime, start playing with Zend_Rest_Route and
standardizing on it for your CRUD operations!</xhtml:p>
</xhtml:div>
    </content>
  </entry>
</feed>
