<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Tag: rest :: phly, boy, phly</title>
  <updated>2013-02-12T11:42:00+0000</updated>
  <generator uri="http://framework.zend.com" version="2.1.1dev">Zend_Feed_Writer</generator>
  <link rel="alternate" type="text/html" href="http://mwop.net/blog/tag/rest.html"/>
  <link rel="self" type="application/atom+xml" href="http://mwop.net/blog/tag/rest-atom.xml"/>
  <id>http://mwop.net/blog/tag/rest.html</id>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[RESTful APIs with ZF2, Part 1]]></title>
    <published>2013-02-12T11:42:00+0000</published>
    <updated>2013-02-12T11:42:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2013-02-11-restful-apis-with-zf2-part-1.html"/>
    <id>http://mwop.net/blog/2013-02-11-restful-apis-with-zf2-part-1.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>RESTful APIs have been an interest of mine for a couple of
years, but due to <xhtml:a href="http://framework.zend.com/blog//zend-framework-2-0-0-stable-released.html">
circumstances</xhtml:a>, I've not had much chance to work with them in
any meaningful fashion until recently.</xhtml:p>
<xhtml:p><xhtml:a href="http://akrabat.com/">Rob Allen</xhtml:a> and I proposed a
workshop for <xhtml:a href="http://conference.phpbenelux.eu/2013/">PHP
Benelux 2013</xhtml:a> covering RESTful APIs with ZF2. When it was
accepted, it gave me the perfect opportunity to dive in and start
putting the various pieces together.</xhtml:p>
<xhtml:h2>Background</xhtml:h2>
<xhtml:p>I've attended any number of conference sessions on API design,
read countless articles, and engaged in quite a number of
conversations. Three facts keep cropping up:</xhtml:p>
<xhtml:ol>
<xhtml:li>JSON is fast becoming the preferred exchange format due to the
ease with which it de/serializes in almost every language.</xhtml:li>
<xhtml:li>The "holy grail" is <xhtml:a href="http://martinfowler.com/articles/richardsonMaturityModel.html">Richardson
Maturity Model</xhtml:a> Level 3.</xhtml:li>
<xhtml:li>It's really hard to achieve RMM level 3 with JSON.</xhtml:li>
</xhtml:ol>
<xhtml:h3>Richardson Maturity Model</xhtml:h3>
<xhtml:p>As a quick review, the Richardson Maturity Model has the
following 4 levels:</xhtml:p>
<xhtml:ul>
<xhtml:li>Level 0: "The swamp of POX." Basically, a service that uses TCP
for transport, primarily as a form of remote procedure call (RPC).
Typically, these are not really leveraging HTTP in any meaningful
fashion; most systems will use HTTP POST for all interactions.
Also, you will often have a single endpoint for all interactions,
regardless of whether or not they are strictly related. XML-RPC,
SOAP, and JSON-RPC fall under this category.</xhtml:li>
<xhtml:li>Level 1: "Resources." In these services, you start breaking the
service into multiple services, one per "resource," or, in object
oriented terms, per object. This means a distinct URL per object,
which means each has its own distinct identity on the web; this
often extends not only to the collection of objects, but to
individual objects under the collection as well (e.g., "/books" as
well as "/books/life-of-pi"). The service may still be RPC in
nature, however, and, at this level, often is still using a single
HTTP method for all interactions with the resource.</xhtml:li>
<xhtml:li>Level 2: "HTTP Verbs." At this level, we start using HTTP verbs
with our services in the way the HTTP specification intends. GET is
for safe operations, and should be cacheable; POST is used for
creation and/or updating; DELETE can be used to delete a resource;
etc. Rather than doing RPC style methods, we leverage HTTP,
occasionally passing additional parameters via the query string or
request body. Considerations such as HTTP caching and idempotence
are taken into account.</xhtml:li>
<xhtml:li>Level 3: "Hypermedia Controls." Building on the previous level,
our resource representations now also include <xhtml:em>links</xhtml:em>, which
indicate what we can <xhtml:em>do next</xhtml:em>. At this level, our API
becomes practically self-describing; given a single end-point, we
should be able to start crawling it, using the links in a
representation to lead us to the next actions.</xhtml:li>
</xhtml:ul>
<xhtml:p>When I first started playing with web services around a decade
ago, everything was stuck at Level 0 or Level 1 -- usually with
Level 1 users downgrading to Level 0 because Level 0 offerred
consistency and predictability if you chose to use a service type
that had a defined envelope format (such as XML-RPC or SOAP). (I
even wrote the XML-RPC server implementation for Zend Framework
because I got sick of writing one-off parsers/serializers for
custom XML web service implementations. When you're implementing
many services, predictability is a huge win.)</xhtml:p>
<xhtml:p>A few years ago, I started seeing a trend towards Level 2. Web
developers like the simplicity of using HTTP verbs, as they map
very well to <xhtml:a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</xhtml:a>
operations -- the bread and butter of web development. Couple this
concept with JSON, and it becomes trivially simple to both create a
web service, as well as consume it.</xhtml:p>
<xhtml:p><xhtml:em>I'd argue that the majority of web developers are quite
happy to be at Level 2 -- and have no problem staying there.
They're productive, and the concepts are easy -- both to understand
and to implement.</xhtml:em></xhtml:p>
<xhtml:p>Level 3, though, is where it becomes really interesting. The
idea that I can examine the represention <xhtml:em>alone</xhtml:em> in order to
understand what I can do next is very intriguing and
empowering.</xhtml:p>
<xhtml:h3>JSON and Hypermedia</xhtml:h3>
<xhtml:p>With XML, hypermedia basically comes for free. Add some
&lt;link&gt; elements to your representation, and you're done --
and don't forget the link <xhtml:code>rel</xhtml:code>ations!</xhtml:p>
<xhtml:p>JSON, however, is another story.</xhtml:p>
<xhtml:p>Where do the links go? <xhtml:em>There is no single, defined way to
represent a hyperlink in JSON.</xhtml:em></xhtml:p>
<xhtml:p>Fortunately, there are some emerging standards.</xhtml:p>
<xhtml:p>First is use of the <xhtml:a href="http://www.w3.org/wiki/LinkHeader">"Link" HTTP header</xhtml:a>. While
the page I linked shows only a single link in the header, you can
have multiple links separated by commas. GitHub uses this when
providing pagination links in their API. Critics will point out
that the HTTP headers are not technically part of the
representation, however; strict interpetations of REST and RMM
indicate that the hypermedia links should be part of the resource
representation. Regardless, having the links in the HTTP headers is
useful for pre-traversal of a service, as you can perform HEAD
requests only to discover possible actions and workflows.</xhtml:p>
<xhtml:p><xhtml:a href="http://amundsen.com/media-types/collection/format/">Collection+JSON</xhtml:a>
is interesting, as it describes the entire JSON envelope. My one
criticism is that it details too much; whenever I see a format that
dictates how to describe types, I think of XML-RPC or SOAP, and get
a little twitchy. It's definitely worth a look, though.</xhtml:p>
<xhtml:p>What's captured my attention of late, however, is <xhtml:a href="http://stateless.co/hal_specification.html">Hypertext Application
Language</xhtml:a>, or HAL for short. HAL has very few rules, but
succinctly describes both how to provide hypermedia in JSON as well
as how to represent embedded resources - the two things that most
need standardized structure in JSON. It does this while still
providing a generic media type, and also describing a mirror image
XML format!</xhtml:p>
<xhtml:h3>HAL Media Types</xhtml:h3>
<xhtml:p>HAL defines two generic media types:
<xhtml:code>application/hal+xml</xhtml:code> and
<xhtml:code>application/hal+json</xhtml:code>. You will use these as the
response Content-Type, as they describe the response
representation; the client can simply request
<xhtml:code>application/json</xhtml:code>, and the response format remains
compatible.</xhtml:p>
<xhtml:h3>HAL and Links</xhtml:h3>
<xhtml:p>HAL provides a very simple structure for JSON hypermedia links.
First, all resource representations must contain hypermedia links,
and all links are provided in a "_links" object:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Second, links are properties of this object. The property name
is the link relation, and the value is an object containing
minimally an "href" property.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status/1234"}
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>If a given relation can have multiple links, you provide instead
an array of objects:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status/1234"},
        "conversation": [
            {"href": "http://example.com/api/status/1237"},
            {"href": "http://example.com/api/status/1241"}
        ]
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Individual links can contain other attributes as desired -- I've
seen people include the relation again so that it's self-contained
in the link object, and it's not uncommon to include a title or
name.</xhtml:p>
<xhtml:h3>HAL and Resources</xhtml:h3>
<xhtml:p>HAL imposes no structure over resources other than requiring the
hypermedia links; even then, you typically do not include the
hypermedia links when making a request of the web service; the
hypermedia links are included only in the representations
<xhtml:em>returned</xhtml:em> by the service.</xhtml:p>
<xhtml:p>So, as an example, you would POST the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
POST /api/status
Host: example.com
Accept: application/json
Content-Type: application/json

{
    "status": "This is my awesome status update!",
    "user": "mwop"
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>And from that request, you'd receive the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="http">
201 Created
Location: http://example.com/api/status/1347
Content-Type: application/hal+json

{
    "_links": {
        "self": {"href": "http://example.com/api/status/1347"}
    },
    "id": "1347",
    "timestamp": "2013-02-11 23:33:47",
    "status": "This is my awesome status update!",
    "user": "mwop"
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:h3>HAL and Embedded Resources</xhtml:h3>
<xhtml:p>The other important thing that HAL defines is how to
<xhtml:em>embed</xhtml:em> resources. Why is this important? If the resource
references other resources, you will want to be able to link to
them so you can perform operations on them, too.</xhtml:p>
<xhtml:p>Embedded resources are represented inside an "_embedded" object
of the representation, and, as resources, contain their own
"_links" object as well. Each resource you embed is assigned to a
property of that object, and if multiple objects of the same type
are returned, an array of resources is assigned. In fact, this
latter is how you represent <xhtml:em>collections</xhtml:em> in HAL.</xhtml:p>
<xhtml:p>Let's consider a simple example first. In previous code samples,
I have a "user" that's a string; let's make that an embedded
resource instead.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status/1347"}
    },
    "id": "1347",
    "timestamp": "2013-02-11 23:33:47",
    "status": "This is my awesome status update!",
    "_embedded": {
        "user": {
            "_links": {
                "self": {"href": "http://example.com/api/user/mwop"}
            }
            "id": "mwop",
            "name": "Matthew Weier O'Phinney",
            "url": "http://mwop.net"
        }
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>I've moved the "user" out of the representation, and into the
"_embedded" object -- because this is where you define embedded
resources. Note that the "user" is a standard HAL resource itself
-- containing hypermedia links.</xhtml:p>
<xhtml:p>Now let's look at a collection:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="javascript">
{
    "_links": {
        "self": {"href": "http://example.com/api/status"},
        "next": {"href": "http://example.com/api/status?page=2"},
        "last": {"href": "http://example.com/api/status?page=100"}
    },
    "count": 2973,
    "per_page": 30,
    "page": 1,
    "_embedded": {
        "status": [
            {
                "_links": {
                    "self": {"href": "http://example.com/api/status/1347"}
                },
                "id": "1347",
                "timestamp": "2013-02-11 23:33:47",
                "status": "This is my awesome status update!",
                "_embedded": {
                    "user": {
                        "_links": {
                            "self": {"href": "http://example.com/api/user/mwop"}
                        }
                        "id": "mwop",
                        "name": "Matthew Weier O'Phinney",
                        "url": "http://mwop.net"
                    }
                }
            }
            /* ... */
        ]
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Note that the "status" property is an array; semantically, all
resources under this key are of the same type. Also note that the
parent resource has some additional link relations -- these are
related to pagination, and allow a client to determine what the
next and last pages are (and, if we were midway into the
collection, previous and first pages). Since the collection is also
a resource, it has some interesting metadata -- how many resources
are in the collection, how many we represent per page, and what the
current page is.</xhtml:p>
<xhtml:p>Also note that you can nest resources -- simply include an
"_embedded" object inside an embedded resource, with additional
resources, as I've done with the "user" resource inside the status
resource shown here. It's turtles all the way down.</xhtml:p>
<xhtml:h2>Next Time</xhtml:h2>
<xhtml:p>The title of this post indicates I'll be talking about building
RESTful APIs with ZF2 -- but so far, I've not said anything about
ZF2.</xhtml:p>
<xhtml:p>I'll get there. But there's another detour to take: reporting
errors.</xhtml:p>
<xhtml:p><xhtml:em>Note: I'll update this post with links to the other posts in
the series as I publish them.</xhtml:em></xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Responding to Different Content Types in RESTful ZF Apps]]></title>
    <published>2010-03-04T20:28:07+0000</published>
    <updated>2010-03-10T14:28:22+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/233-Responding-to-Different-Content-Types-in-RESTful-ZF-Apps.html"/>
    <id>http://mwop.net/blog/233-Responding-to-Different-Content-Types-in-RESTful-ZF-Apps.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>In <xhtml:a href="/matthew/archives/227-Exposing-Service-APIs-via-Zend-Framework.html">
previous</xhtml:a> <xhtml:a href="/matthew/archives/228-Building-RESTful-Services-with-Zend-Framework.html">
articles</xhtml:a>, I've explored building service endpoints and RESTful
services with Zend Framework. With RPC-style services, you get to
cheat: the protocol dictates the content type (XML-RPC uses XML,
JSON-RPC uses JSON, SOAP uses XML, etc.). With REST, however, you
have to make choices: what serialization format will you
support?</xhtml:p>
<xhtml:p>Why not support multiple formats?</xhtml:p>
<xhtml:p>There's no reason you can't re-use your RESTful web service to
support multiple formats. Zend Framework and PHP have plenty of
tools to assist you in responding to different format requests, so
don't limit yourself. With a small amount of work, you can make
your controllers format agnostic, and ensure that you respond
appropriately to different requests.</xhtml:p>
<xhtml:h2>Content-Type Detection</xhtml:h2>
<xhtml:p>The first problem to solve is going to be how to retrieve passed
parameters. When using XML or JSON as your serialization format,
you aren't getting your standard POST variables -- you're getting a
raw post instead, and you'll need to deserialize the payload. In
fact, if you're getting a PUT request, you also have some work to
do, as PHP doesn't do anything with PUT requests.</xhtml:p>
<xhtml:p>I do this via an action helper. The basic algorithm is:</xhtml:p>
<xhtml:ul>
<xhtml:li>Do we have a raw body in the request? If not, nothing more need
be done.</xhtml:li>
<xhtml:li>Determine the Content-Type passed in the request headers, and
decode appropriately:
<xhtml:ul>
<xhtml:li>If it was JSON, pass the raw request body to
<xhtml:code>json_decode</xhtml:code> or <xhtml:code>Zend_Json::decode</xhtml:code>.</xhtml:li>
<xhtml:li>If it was XML, I pass the raw request body to the
<xhtml:code>Zend_Config_XML</xhtml:code> constructor, and then serialize to an
arrya using the <xhtml:code>toArray()</xhtml:code> method. Yes, it's a hack,
but it's effective.</xhtml:li>
<xhtml:li>Otherwise, I assume I've got a regular PUT-style request, and I
pass the data to <xhtml:code>parse_str()</xhtml:code>.</xhtml:li>
</xhtml:ul>
</xhtml:li>
</xhtml:ul>
<xhtml:p>I keep the values within the action helper, and then retrieve
them on demand within my action controller. The helper looks like
the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Scrummer_Controller_Helper_Params 
    extends Zend_Controller_Action_Helper_Abstract
{
    /**
     * @var array Parameters detected in raw content body
     */
    protected $_bodyParams = array();

    /**
     * Do detection of content type, and retrieve parameters from raw body if 
     * present
     * 
     * @return void
     */
    public function init()
    {
        $request     = $this-&gt;getRequest();
        $contentType = $request-&gt;getHeader('Content-Type');
        $rawBody     = $request-&gt;getRawBody();
        if (!$rawBody) {
            return;
        }
        switch (true) {
            case (strstr($contentType, 'application/json')):
                $this-&gt;setBodyParams(Zend_Json::decode($rawBody));
                break;
            case (strstr($contentType, 'application/xml')):
                $config = new Zend_Config_Xml($rawBody);
                $this-&gt;setBodyParams($config-&gt;toArray());
                break;
            default:
                if ($request-&gt;isPut()) {
                    parse_str($rawBody, $params);
                    $this-&gt;setBodyParams($params);
                }
                break;
        }
    }

    /**
     * Set body params
     * 
     * @param  array $params 
     * @return Scrummer_Controller_Action
     */
    public function setBodyParams(array $params)
    {
        $this-&gt;_bodyParams = $params;
        return $this;
    }

    /**
     * Retrieve body parameters
     * 
     * @return array
     */
    public function getBodyParams()
    {
        return $this-&gt;_bodyParams;
    }

    /**
     * Get body parameter
     * 
     * @param  string $name 
     * @return mixed
     */
    public function getBodyParam($name)
    {
        if ($this-&gt;hasBodyParam($name)) {
            return $this-&gt;_bodyParams[$name];
        }
        return null;
    }

    /**
     * Is the given body parameter set?
     * 
     * @param  string $name 
     * @return bool
     */
    public function hasBodyParam($name)
    {
        if (isset($this-&gt;_bodyParams[$name])) {
            return true;
        }
        return false;
    }

    /**
     * Do we have any body parameters?
     * 
     * @return bool
     */
    public function hasBodyParams()
    {
        if (!empty($this-&gt;_bodyParams)) {
            return true;
        }
        return false;
    }

    /**
     * Get submit parameters
     * 
     * @return array
     */
    public function getSubmitParams()
    {
        if ($this-&gt;hasBodyParams()) {
            return $this-&gt;getBodyParams();
        }
        return $this-&gt;getRequest()-&gt;getPost();
    }

    public function direct()
    {
        return $this-&gt;getSubmitParams();
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>This helper is intended to be run on each request, so I register
it in my bootstrap:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Bootstrap extends Zend_Application_Bootstrap_Bootstrap
{
    // ...
    protected function _initActionHelpers()
    {
        // ...
        $params = new Scrummer_Controller_Helper_Params();
        Zend_Controller_Action_HelperBroker::addHelper($params);
        // ...
    }
    // ...
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Within your action controller, all you need to do is call the
helper:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
$data = $this-&gt;params();
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>In a RESTful controller, you'll only need to use this with your
<xhtml:code>postAction</xhtml:code> and <xhtml:code>putAction</xhtml:code>. The beauty is
that your controller can remain ignorant of the Content-Type -- you
write the same logic to retrieve your parameters regardless.</xhtml:p>
<xhtml:h2>Responding to the client: Context Switching</xhtml:h2>
<xhtml:p>So, the first half of the problem is taken care of: how to
handle the request. The second half is responding
appropriately.</xhtml:p>
<xhtml:p>Zend Framework has some built in tooling to help with this. The
ContextSwitch and AjaxContext action helpers look for a particular
parameter -- "format" by default -- and, if detected, will render
an alternate view script named after the context. As an example, if
an "XML" context is detected, it will render
"&lt;controller&gt;/&lt;action&gt;.xml.phtml" -- note the ".xml"
segment of the script name.</xhtml:p>
<xhtml:p>Both helpers work in the same basic way (the latter,
AjaxContext, will only activate if the request is determined to
originate from an XMLHttpRequest): you define which actions in the
controller are context sensitive, and then if the context is
detected, a new view script will be used.</xhtml:p>
<xhtml:p>So, the first trick is ensuring that the context is passed. As
mentioned before, the helpers look for a "format" parameter in the
request object. You can pass this using a query parameter --
"?format=xml" -- but I find that ugly. There's an HTTP header
defined for this purpose already: "Accept".</xhtml:p>
<xhtml:p>Detecting the header and injecting the context into the request
is absurdly simple, and can be done in a
<xhtml:code>dispatchLoopStartup</xhtml:code> plugin:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Scrummer_Controller_Plugin_AcceptHandler
    extends Zend_Controller_Plugin_Abstract
{
    public function dispatchLoopStartup(Zend_Controller_Request_Abstract $request)
    {
        if (!$request instanceof Zend_Controller_Request_Http) {
            return;
        }

        $header = $request-&gt;getHeader('Accept');
        switch (true) {
            case (strstr($header, 'application/json')):
                $request-&gt;setParam('format', 'json');
                break;
            case (strstr($header, 'application/xml') 
                  &amp;&amp; (!strstr($header, 'html'))):
                $request-&gt;setParam('format', 'xml');
                break;
            default:
                break;
        }
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The above can be registered in your application
configuration:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="ini" xml:lang="ini">
resources.frontController.plugins[] = \"Scrummer_Controller_Plugin_AcceptHandler\"
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>I like my RESTful controllers to automatically expose their
methods as context-aware. To make this happen, I defined a marker
interface, "Scrummer_Rest_Controller", and created an action helper
that checks if the current controller implements it; if it does, I
then automatically add contexts for the RESTful actions.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Scrummer_Controller_Helper_RestContexts
    extends Zend_Controller_Action_Helper_Abstract
{
    protected $_contexts = array(
        'xml', 
        'json',
    );

    public function preDispatch()
    {
        $controller = $this-&gt;getActionController();
        if (!$controller instanceof Scrummer_Rest_Controller) {
            return;
        }

        $this-&gt;_initContexts();

        // Set a Vary response header based on the Accept header
        $this-&gt;getResponse()-&gt;setHeader('Vary', 'Accept');
    }

    protected function _initContexts()
    {
        $cs = $this-&gt;getActionController()-&gt;contextSwitch;
        $cs-&gt;setAutoJsonSerialization(false);
        foreach ($this-&gt;_contexts as $context) {
            foreach (array('index', 'post', 'get', 'put', 'delete') as $action) {
                $cs-&gt;addActionContext($action, $context);
            }
        }
        $cs-&gt;initContext();
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Register this via the bootstrap as well:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
class Bootstrap extends Zend_Application_Bootstrap_Bootstrap
{
    // ...
    protected function _initActionHelpers()
    {
        // ...
        $params = new Scrummer_Controller_Helper_Params();
        Zend_Controller_Action_HelperBroker::addHelper($params);

        $contexts = new Scrummer_Controller_Helper_RestContexts();
        Zend_Controller_Action_HelperBroker::addHelper($contexts);
        // ...
    }
    // ...
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>There are two things to note about this helper. First, you'll
see that I specify a "Vary" header. This is to ensure that if the
client chooses to cache responses, it will cache separate responses
based on the value sent in the "Accept" header.</xhtml:p>
<xhtml:p>Second, note that I turn off automatic JSON serialization in the
ContextSwitch helper. I do this so that I can keep my controller
context agnostic; this will require additional view scripts, but
the ability to keep my controller logic simple will be worth it.
More on that in a moment.</xhtml:p>
<xhtml:p>We now have the infrastructure in place to respond to different
contexts based on the "Accept" header, and can retrieve parameters
appropriately based on the "Content-Type" provided us. Now comes
the actual response.</xhtml:p>
<xhtml:h2>Responding to the client: Views</xhtml:h2>
<xhtml:p>Recall that ContextSwitch will attach an additional prefix to
the specified view script --
"&lt;controller&gt;/&lt;action&gt;.phtml" will become
"&lt;controller&gt;/&lt;action&gt;.xml.phtml" or
"&lt;controller&gt;/&lt;action&gt;.json.phtml". Basically, for each
context we will respond to, we have an additional view script per
action.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="text" xml:lang="text">
views/
|-- scripts/
|   `-- foo/
|      |-- delete.phtml
|      |-- delete.json.phtml
|      |-- delete.xml.phtml
|      |-- get.phtml
|      |-- get.json.phtml
|      |-- get.xml.phtml
|      |-- index.phtml
|      |-- index.json.phtml
|      |-- index.xml.phtml
|      |-- post.phtml
|      |-- post.json.phtml
|      |-- post.xml.phtml
|      |-- put.phtml
|      |-- put.json.phtml
|      `-- put.xml.phtml
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>This may seem like overkill, but consider the following
representative method from my controller:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
    public function postAction()
    {
        $data    = $this-&gt;params();
        $service = $this-&gt;getService();
        $result  = $service-&gt;add($data);  
        if (!$result) {
            $this-&gt;view-&gt;form = $service-&gt;getBacklogForm();
            return;
        }

        $this-&gt;view-&gt;success = true;
        $this-&gt;view-&gt;backlog = $result;
    }
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>You don't see anything in there about headers, redirects, or XHR
requests. Just slinging data to services and views. Real
simple.</xhtml:p>
<xhtml:p>The view scripts then take care of the appropriate display
logic. Let's look at two view scripts for the above action, one for
plain old HTML, the other for a JSON response:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
&lt;?php // backlog/post.phtml ?&gt;
&lt;?php 
if ($this-&gt;success):
    $this-&gt;response-&gt;setRedirect($this-&gt;url(array(
        'controller' =&gt; 'backlog',
        'id'         =&gt; $this-&gt;backlog-&gt;id,
    ), 'rest', true));
else: ?&gt;
&lt;h2&gt;Create new backlog&lt;/h2&gt;
&lt;?php
    $this-&gt;form-&gt;setAction($this-&gt;url())
               -&gt;setMethod('post');
    echo $this-&gt;form;
endif ?&gt;

&lt;?php // backlog/post.json.phtml ?&gt;
&lt;?php
if ($this-&gt;success) {
    $url = $this-&gt;url(array(
        'controller' =&gt; 'backlog',
        'id'         =&gt; $this-&gt;backlog-&gt;id,
    ), 'rest', true);
    $this-&gt;response-&gt;setHeader('Location', $url)
                   -&gt;setHttpResponseCode(201);
    echo $this-&gt;json($this-&gt;backlog-&gt;toArray());
    return;
}

$form = $this-&gt;form;
$form-&gt;setAction($this-&gt;url())
     -&gt;setMethod('post');
echo $this-&gt;jsonFormErrors($form);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>A few things to note: I inject my response object into the view.
I feel HTTP headers are part of the view, and thus I deal with them
there. That also serves the purpose of keeping my controllers thin
and agnostic. Additionally, you'll note that I use different
response codes for HTML versus JSON -- this allows my JSON-REST
support to be RESTful, by returning a 201 status code indicating
the resource was created; I also return a JSON representation of
the object. Finally, you'll note that I have a special view helper
for creating JSON representations of validation errors.</xhtml:p>
<xhtml:h2>Closing points</xhtml:h2>
<xhtml:p>This post is far from exhaustive, and I expect it will likely
raise at least as many questions as it tries to answer.</xhtml:p>
<xhtml:p>My main point in this article is to get you, the reader and
developer, thinking creatively about how to expose RESTful web
services. Hopefully, you're taking the following away:</xhtml:p>
<xhtml:ol>
<xhtml:li>Architect in such a way as to minimize the code in your
controllers; keep that code as agnostic as possible in regards to
where input comes from and what type of response is required.</xhtml:li>
<xhtml:li>Use front controller plugins and action helpers to create
scaffolding for your services; these are incredibly flexible and
re-usable, and help make point 1 that much easier.</xhtml:li>
<xhtml:li>Offload as much as possible to your views. This will allow you
to isolate logic specific to given formats.</xhtml:li>
</xhtml:ol>
<xhtml:p>What are you waiting for? Don't you have an API to expose?</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Building RESTful Services with Zend Framework]]></title>
    <published>2009-11-09T14:00:00+0000</published>
    <updated>2009-11-11T15:38:41+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/228-Building-RESTful-Services-with-Zend-Framework.html"/>
    <id>http://mwop.net/blog/228-Building-RESTful-Services-with-Zend-Framework.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>As a followup to my <xhtml:a href="/matthew/archives/227-Exposing-Service-APIs-via-Zend-Framework.html">
previous post</xhtml:a>, I now turn to RESTful web services. I originally
encountered the term when attending php|tropics in 2005, where
<xhtml:a href="http://twitter.com/g_schlossnagle">George
Schlossnaggle</xhtml:a> likened it to simple GET and POST requests. Since
then, the architectural style -- and developer understanding of the
architectural style -- has improved a bit, and a more solid
definition can be made.</xhtml:p>
<xhtml:p>At its heart, <xhtml:a href="http://en.wikipedia.org/wiki/Representational_State_Transfer"/>REST
simply dictates that a given resource have a unique address, and
that you interact with that resource using HTTP verbs. The standard
verbs utilized are:</xhtml:p>
<xhtml:ul>
<xhtml:li><xhtml:em>GET</xhtml:em>: retrieve a list of resources, or, if an
identifier is present, view a single resource</xhtml:li>
<xhtml:li><xhtml:em>POST</xhtml:em>: create a new resource with the data provided in
the POST</xhtml:li>
<xhtml:li><xhtml:em>PUT</xhtml:em>: update an existing resource as specified by an
identifier, using the PUT data</xhtml:li>
<xhtml:li><xhtml:em>DELETE</xhtml:em>: delete an existing resource as specified by an
identifier</xhtml:li>
</xhtml:ul>
<xhtml:p>The standard URL structure used is as follows:</xhtml:p>
<xhtml:ul>
<xhtml:li>"/resource" - GET (list) and POST operations</xhtml:li>
<xhtml:li>"/resource/{identifier}" - GET (view), PUT, and DELETE
operations</xhtml:li>
</xhtml:ul>
<xhtml:p>What the REST paradigm provides you is a simple, standard way to
structure your CRUD (Create-Read-Update-Delete) applications. Due
to the large number of REST clients available, it also means that
if you follow the rules, you get a ton of interoperability with
those clients.</xhtml:p>
<xhtml:p>As of <xhtml:a href="http://framework.zend.com/">Zend Framework</xhtml:a>
1.9.0, it's trivially easy to create RESTful routes for your MVC
application, as well as to handle the various REST actions via
action controllers.</xhtml:p>
<xhtml:p><xhtml:a href="http://framework.zend.com/manual/en/zend.controller.router.html#zend.controller.router.routes.rest">
Zend_Rest_Route</xhtml:a> allows you to define RESTful controllers at
several levels:</xhtml:p>
<xhtml:ul>
<xhtml:li>You can make it the default route, meaning that unless you have
additional routes, all controllers will be considered REST
controllers.</xhtml:li>
<xhtml:li>You can specify modules that contain RESTful controllers.</xhtml:li>
<xhtml:li>You can specify specific controllers per module that are
RESTful</xhtml:li>
</xhtml:ul>
<xhtml:p>As examples:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
$front = Zend_Controller_Front::getInstance();
$router = $front-&gt;getRouter();

// Specifying all controllers as RESTful:
$restRoute = new Zend_Rest_Route($front);
$router-&gt;addRoute('default', $restRoute);

// Specifying the \"api\" module only as RESTful:
$restRoute = new Zend_Rest_Route($front, array(), array(
    'api',
));
$router-&gt;addRoute('rest', $restRoute);

// Specifying the \"api\" module as RESTful, and the \"task\" controller of the
// \"backlog\" module as RESTful:
$restRoute = new Zend_Rest_Route($front, array(), array(
    'api',
    'backlog' =&gt; array('task'),
));
$router-&gt;addRoute('rest', $restRoute);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>To define a RESTful action controller, you can either extend
Zend_Rest_Controller, or simply define the following methods in a
standard controller extending Zend_Controller_Action (you'll need
to define them regardless):</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
// Or extend Zend_Rest_Controller
class RestController extends Zend_Controller_Action
{
    // Handle GET and return a list of resources
    public function indexAction() {}

    // Handle GET and return a specific resource item
    public function getAction() {}

    // Handle POST requests to create a new resource item
    public function postAction() {}

    // Handle PUT requests to update a specific resource item
    public function putAction() {}

    // Handle DELETE requests to delete a specific item
    public function deleteAction() {}
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>For those methods that operate on individual resources
(getAction(), putAction(), and deleteAction()), you can test for
the identifier using the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code lang="php" xml:lang="php">
if (!$id = $this-&gt;_getParam('id', false)) {
    // report error, redirect, etc.
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:h2>Responding is an art</xhtml:h2>
<xhtml:p>Many developers are either unaware of or ignore the part of the
specification that dictates what the <xhtml:em>response</xhtml:em> should look
like.</xhtml:p>
<xhtml:p>For instance, in classic REST, after performing a POST to create
a new item, you should do the following:</xhtml:p>
<xhtml:ul>
<xhtml:li>Set the HTTP response code to 201, indicating "Created"</xhtml:li>
<xhtml:li>Set the Location header to point to the canonical URI for the
newly created item: "/team/31"</xhtml:li>
<xhtml:li>Provide a representation of the newly created item</xhtml:li>
</xhtml:ul>
<xhtml:p>Note that there's no redirect, which flies in the face of
standard web development (where GET-POST-Redirect is the typical
format). This is a common "gotcha" moment.</xhtml:p>
<xhtml:p>Similarly, with PUT requests, you simply indicate an HTTP 200
status when successful, and show a representation of the updated
item. DELETE requests should return an HTTP 204 status (indicating
success - no content), with no body content.</xhtml:p>
<xhtml:p><xhtml:em>Note: when building RESTful HTML applications, you may want
to still do GET-POST-Redirect to prevent caching issues. The above
applies to RESTful web services, which typically use XML or JSON
for transactions, and have smart clients for interacting with the
service.</xhtml:em></xhtml:p>
<xhtml:p>I'll be writing another article soon showing some tips and
tricks for interacting with HTTP headers, both from the request and
for the response, as it's a subject lengthy enough for a post of
its own. In the meantime, start playing with Zend_Rest_Route and
standardizing on it for your CRUD operations!</xhtml:p>
</xhtml:div>
    </content>
  </entry>
</feed>
