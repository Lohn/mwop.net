<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/">
  <channel>
    <title>Blog Entries :: phly, boy, phly</title>
    <description>Blog Entries :: phly, boy, phly</description>
    <pubDate>Tue, 02 Sep 2014 13:30:00 +0000</pubDate>
    <generator>Zend_Feed_Writer 2 (http://framework.zend.com)</generator>
    <link>http://mwop.net/blog.html</link>
    <atom:link rel="self" type="application/rss+xml" href="http://mwop.net/blog-rss.xml"/>
    <item>
      <title>Deployment with Zend Server (Part 3 of 8)</title>
      <pubDate>Tue, 02 Sep 2014 13:30:00 +0000</pubDate>
      <link>http://mwop.net/blog/2014-09-02-zend-server-deployment-part-3.html</link>
      <guid>http://mwop.net/blog/2014-09-02-zend-server-deployment-part-3.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    This is the third in a series of eight posts detailing tips on deploying
    to Zend Server. <a href="/blog/2014-08-28-zend-server-deployment-part-2.html">The previous post in the series</a>
    detailed creating recurring jobs via Zend Job Queue, Ã  la cronjobs.
</p>

<p>
    Today, I'm sharing a very short deployment script tip learned by experience.
</p><h2>Tip 3: chmod</h2>

<p>
    In the <a href="/blog/2014-08-11-zend-server-deployment-part-1.html">first tip</a>,
    I detailed writing deployment scripts. One of the snippets I shared was a <kbd>chmod</kbd>
    routine:
</p>

<div class="example"><pre><code language="php">
$command = 'chmod -R a+rwX ./data';
echo "\nExecuting `$command`\n";
system($command);
</code></pre></div>

<p>
    The code is fine; what I did not share is <em>where</em> in the deployment script
    you should invoke it. As I discovered from experience, this is key.
</p>

<p>
    Zend Server's deployment scripts run as the <kbd>zend</kbd> user. If they are 
    writing any data to the <kbd>data</kbd> directory, that data is owned by the <kbd>zend</kbd> 
    user and group -- and often will not be writable by the web server user.  If you 
    have scheduled jobs that need to write to the same files, they will fail... 
    unless you have done the <kbd>chmod</kbd> after your deployment tasks are done.
</p>

<p>
    So, that's today's tip: if you need any directory in your application to be
    writable by scheduled jobs, which will run as the web server user, make sure
    you do your <kbd>chmod</kbd> as the last step of your deployment script.
</p>

<h2>Next time...</h2>

<p>
    The next tip in the series is another short one, and will detail how to
    secure your Job Queue job scripts.
</p>

<h2>Other articles in the series</h2>

<ul>
    <li><a href="/blog/2014-08-11-zend-server-deployment-part-1.html">Tip 1: zf-deploy</a></li>
    <li><a href="/blog/2014-08-28-zend-server-deployment-part-2.html">Tip 2: Recurring Jobs</a></li>
</ul

<p>
    I will update this post to link to each article as it releases.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>Deployment with Zend Server (Part 2 of 8)</title>
      <pubDate>Tue, 02 Sep 2014 13:30:00 +0000</pubDate>
      <link>http://mwop.net/blog/2014-08-28-zend-server-deployment-part-2.html</link>
      <guid>http://mwop.net/blog/2014-08-28-zend-server-deployment-part-2.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    This is the second in a series of eight posts detailing tips on deploying
    to Zend Server. <a href="/blog/2014-08-11-zend-server-deployment-part-1.html">The previous post in the series</a>
    detailed getting started with <a href="http://www.zend.com/en/solutions/cloud-solutions/aws-marketplace">Zend
    Server on the AWS marketplace</a> and using <a href="https://github.com/zfcampus/zf-deploy">zf-deploy</a>
    to create ZPK packages to deploy to Zend Server.
</p>

<p>
    Today, I'm looking at how to created scheduled/recurring jobs using Zend Server's Job Queue;
    think of this as application-level cronjobs.
</p><h2>Tip 2: Recurring Jobs</h2>

<p>
    I needed to define a few recurring jobs on the server. In the past, I've 
    used <kbd>cron</kbd> for this, but I've recently had a slight change of mind on 
    this: if I use <kbd>cron</kbd>, I have to assume I'm running on a unix-like system, 
    and have some sort of system access to the server. If I have multiple 
    servers running, that means ensuring they're setup on each server. It seems 
    better to be able to define these jobs at the applicaton level.
</p>

<p>
    Since Zend Server comes with Job Queue, I decided to try it out for 
    scheduling recurring jobs. This is not terribly intuitive, however. The UI 
    allows you to define scheduled jobs... but only gives options for every 
    minute, hour, day, week, and month, without allowing you to specify the 
    exact interval (e.g., every day at 20:00).

<p>
    The PHP API, however, makes this easy. I can create a job as follows:
</p>

<div class="example"><pre><code language="php">
$queue = new ZendJobQueue();
$queue->createHttpJob('/jobs/github-feed.php', [], [
  'name'       => 'github-feed',
  'persistent' => false,
  'schedule'   => '5,20,35,40 * * * *',
]);
</code></pre></div>

<p>
    Essentially, you provide a URL to the script to execute (Job Queue "runs" a 
    job by accessing a URL on the server), and provide a schedule in crontab 
    format. I like to give my jobs names as well, as it allows me to search for 
    them in the UI, and also enables linking between the rules and the logs in 
    the UI. Marking them as <em>not</em> persistent ensures that if the job is 
    successful, it will be removed from the events list.
</p>

<p>
    The question is, where do you define this? I decided to do this in my 
    <kbd>post_activate.php</kbd> deployment script. However, this raises two new 
    problems:
</p>

<ul>
    <li>Rules need not just a path to the script, but also the scheme and host. 
        You _can_ omit those, but only if the script can resolve them via 
        <kbd>$_SERVER</kbd>... which it cannot due during deployment.</li>
    <li>Each deployment adds the jobs you define... but this does not overwrite 
        or remove the jobs you added in previous deployments.</li>
</ul>

<p>
    I solved these as follows:
</p>

<div class="example"><pre><code language="php">
$server = 'http://mwop.net';

// Remove previously scheduled jobs:
$queue = new ZendJobQueue();
foreach ($queue->getSchedulingRules() as $job) {
    if (0 !== strpos($job['script'], $server)) {
        // not one we're interested in
        continue;
    }

    // Remove previously scheduled job
    $queue->deleteSchedulingRule($job['id']);
}

$queue->createHttpJob($server . '/jobs/github-feed.php', [], [
  'name'       => 'github-feed',
  'persistent' => false,
  'schedule'   => '5,20,35,40 * * * *',
]);
</code></pre></div>

<p>
    So, in summary:
</p>

<ul>
    <li>Define your rules with names.</li>
    <li>Define recurring rules using the <kbd>schedule</kbd> option.</li>
    <li>Define recurring rules in your deployment script, during <kbd>post_activate</kbd>.</li>
    <li>Remove previously defined rules in your deployment script, prior to defining them.</li>
</ul>

<h2>Next time...</h2>

<p>
    The next tip in the series is a short one, perfect for following the US 
    Labor Day weekend, and details something I learned the hard way from Tip 1 
    when setting up deployment tasks.
</p>

<h2>Other articles in the series</h2>

<ul>
    <li><a href="/blog/2014-08-11-zend-server-deployment-part-1.html">Tip 1: zf-deploy</a></li>
    <li><a href="/blog/2014-09-02-zend-server-deployment-part-3.html">Tip 3: chmod</a></li>
</ul

<p>
    I will update this post to link to each article as it releases.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>Deployment with Zend Server (Part 1 of 8)</title>
      <pubDate>Tue, 02 Sep 2014 13:30:00 +0000</pubDate>
      <link>http://mwop.net/blog/2014-08-11-zend-server-deployment-part-1.html</link>
      <guid>http://mwop.net/blog/2014-08-11-zend-server-deployment-part-1.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    I manage a number of websites running on Zend Server, Zend's PHP 
    application platform. I've started accumulating a number of patterns and 
    tricks that make the deployments more successful, and which also allow 
    me to do more advanced things such as setting up recurring jobs for the 
    application, clearing page caches, and more.
</p><h2>Yes, YOU can afford Zend Server</h2>

<p>
    "But, wait, Zend Server is uber-expensive!" I hear some folks saying.
</p>

<p>
    Well, yes and no.
</p>

<p>
    With the release of Zend Server 7, Zend now offers a "Development 
    Edition" that contains all the features I've covered here, and which 
    runs $195. This makes it affordable for small shops and freelancers, 
    but potentially out of the reach of individuals.
</p>

<p>
    But there's another option, which I'm using, which is even more 
    intriguing: <a href="http://www.zend.com/en/solutions/cloud-solutions/aws-marketplace">Zend Server on the Amazon Web Services (AWS) Marketplace</a>. 
    On AWS, you can try out Zend Server free for 30 days. After that, 
    you get charged a fee on top of your normal AWS EC2 usage. Depending 
    on the EC2 instance you choose, this can run as low as ~$24/month 
    (this is on the t1.micro, and that's the total per month for both 
    AWS and Zend Server usage). That's cheaper than most VPS hosting or 
    PaaS providers, and gives you a full license for Zend Server.
</p>

<p>
    Considering Zend Server is available on almost every PaaS and IaaS 
    offering available, this is a great way to try it out, as well as to 
    setup staging and testing servers cheaply; you can then choose the
    provider you want based on its other features. For those of you running 
    low traffic or small, personal or hobbyist sites, it's an 
    inexpensive alternative to VPS hosting.
</p>

<p>
    So... onwards with my first tip.
</p>

<h2>Tip 1: zf-deploy</h2>

<p>
    My first trick is to use 
    <a href="https://github.com/zfcampus/zf-deploy">zf-deploy</a>. This is a tool 
    <a href="https://twitter.com/ezimuel">Enrico</a> and I wrote when prepping 
    <a href="https://apigility.org">Apigility</a> for its initial stable release. 
    It allows you to create deployment packages from your application, 
    including zip, tarball, and ZPKs (Zend Server deployment packages). 
    We designed it to simplify packaging <a href="http://framework.zend.com">Zend Framework 2</a> and Apigility applications, but with a 
    small amount of work, it could likely be used for a greater variety 
    of PHP applications.
</p>

<p>
    zf-deploy takes the current state of your working directory, and 
    clones it to a working path. It then runs Composer (though you can 
    disable this), and strips out anything configured in your 
    <kbd>.gitignore</kbd> file (again, you can disable this). From there, it 
    creates your package.
</p>

<p>
    One optional piece is that, when creating a ZPK, you can tell it 
    which <kbd>deployment.xml</kbd> you want to use and/or specify a directory 
    containing the <kbd>deployment.xml</kbd> and any install scripts you want to 
    include in the package. This latter is incredibly useful, as you can 
    use this to shape your deployment.
</p>

<p>
    As an example, on my own website, I have a CLI job that will fetch 
    my latest <a href="https://github.com">GitHub</a> activity. I can invoke that 
    in my <kbd>post_stage.php</kbd> script:
</p>

<div class="example"><pre><code language="php">
if (! chdir(getenv('ZS_APPLICATION_BASE_DIR'))) {
  throw new Exception('Unable to change to application directory');
}

$php = '/usr/local/zend/bin/php';

$command = $php . ' public/index.php githubfeed fetch';
echo "\nExecuting `$command`\n";
system($command);
</code></pre></div>

<p>
    One task I always do is make sure my application data directory is 
    writable by the web server. This next line builds on the above, in 
    that it assumes you've changed to your application directory first:
</p>

<div class="example"><pre><code language="php">
$command = 'chmod -R a+rwX ./data';
echo "\nExecuting `$command`\n";
system($command);
</code></pre></div>

<p>
    Yes, PHP has a built-in for <kbd>chmod</kbd>, but it doesn't act recursively.
</p>

<p>
    For ZF2 and Apigility applications, zf-deploy also allows you to 
    specify a directory that contains the <kbd>*local.php</kbd> config 
    scripts for your <kbd>config/autoload/</kbd> directory, allowing you to 
    merge in configuration specific for the deployment environment. 
    This is a fantastic capability, as I can keep any private 
    configuration separate from my main repository.
</p>

<p>
    Deployment now becomes:
</p>

<div class="example"><pre><code language="bash">
$ vendor/bin/zfdeploy.php mwop.net.zpk --configs=../mwop.net-config --zpk=zpk
</code></pre></div>

<p>
    and I now have a ZPK ready to push to Zend Server.
</p>

<p>
    In sum: zf-deploy simplifies ZPK creation, and allows you to add 
    deployment scripts that let you perform other tasks on the server.
</p>

<h2>Next time...</h2>

<p>
    I've got a total of 8 tips queued up, including this one, and will 
    be publishing on Tuesdays and Thursdays; I'll update each post
    to link to the others in the series. Next tip: creating scheduled
    Job Queue jobs, Ã  la cronjobs.
</p>

<h2>Other articles in the series</h2>

<ul>
    <li><a href="/blog/2014-08-28-zend-server-deployment-part-2.html">Tip 2: Recurring Jobs</a></li>
    <li><a href="/blog/2014-09-02-zend-server-deployment-part-3.html">Tip 3: chmod</a></li>
</ul

<p>
    I will update this post to link to each article as it releases.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>Testing Code That Emits Output</title>
      <pubDate>Thu, 21 Aug 2014 19:30:00 +0000</pubDate>
      <link>http://mwop.net/blog/2014-08-11-testing-output-generating-code.html</link>
      <guid>http://mwop.net/blog/2014-08-11-testing-output-generating-code.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    Here's the scenario: you have code that will emit headers and content,
    for instance, a front controller. How do you test this?
</p>

<p>
    The answer is remarkably simple, but non-obvious: namespaces.
</p><h2>Prerequisites</h2>

<p>
    For this approach to work, the assumptions are:
</p>

<ul>
    <li>Your code emitting headers and output lives in a namespace other than the global namespace.</li>
</ul>

<p>
    That's it. Considering that most PHP code you grab anymore does this, and
    most coding standards you run across will require this, it's a safe bet
    that you're already ready. If you're not, go refactor your code now, before
    continuing; you'll thank me later.
</p>

<h2>The technique</h2>

<p>
    PHP introduced namespaces in PHP 5.3. Namespaces cover classes, as most of
    us are well aware, but they also cover constants and functions -- a fact
    often overlooked, as before 5.6 (releasing next week!), you cannot import
    them via <kbd>use</kbd> statements!
</p>

<p>
    That does not mean they cannot be defined and used, however -- it just
    means that you need to manually import them, typically via a
    <kbd>require</kbd> or <kbd>require_once</kbd> statement. These are usually
    anathema in libraries, but for testing, they work just fine.
</p>

<p>
    Here's an approach I took recently. I created a file that lives -- this is
    the important bit, so pay attention -- <em>in the same namespace as the
    code emitting headers and output</em>. This file defines several functions
    that live in the global (aka PHP's built-in) namespace, and an accumulator
    static object I can then use in my tests for assertions. Here's what it
    looks like:
</p>

<div class="example"><pre><code language="php">
namespace Some\Project;

abstract class Output
{
    public static $headers = array();
    public static $body;

    public static function reset()
    {
        self::$headers = array();
        self::$body = null;
    }
}

function headers_sent()
{
    return false;
}

function header($value)
{
    Output::$headers[] = $value;
}

function printf($text)
{
    Output::$body .= $text;
}
</code></pre></div>

<p>
    A few notes:
</p>

<ul>
    <li><kbd>headers_sent()</kbd> always returns <kbd>false</kbd> here, as most
        emitters test for a boolean <kbd>true</kbd> value and bail early when
        that occurs.</li>

    <li>I used <kbd>printf()</kbd> here, as <kbd>echo</kbd> cannot be overridden
        due to being a PHP language construct and not an actual function. As such,
        if you use this technique, you will have to likely alter your emitter
        to call <kbd>printf()</kbd> instead of <kbd>echo</kbd>. The benefits,
        however, are worth it.</li>

    <li>I marked <kbd>Output</kbd> abstract, to prevent instantiation; it should
        only be used statically.</kbd>
</ul>

<p>
    I place the above file within my test suite, usually under a "TestAsset"
    directory adjacent to the test itself; since it contains functions, I'll 
    name the file "Functions.php" as well. This combination typically will 
    prevent it from being autoloaded in any way, as the test directory will 
    often not have autoloading defined, or will be under a separate namespace.
</p>

<p>
    Inside your PHPUnit test suite, then, you would do the following:
</p>

<div class="example"><pre><code language="php">
namespace SomeTest\Project;

use PHPUnit_Framework_TestCase as TestCase;
use Some\Project\FrontController;
use Some\Project\Output;                 // <-- our Output class from above
require_once __DIR__ . '/TestAsset/Functions.php'; // <-- get our functions

class FrontControllerTest extends TestCase
{
    public function setUp()
    {
        Output::reset();
        /* ... */
    }

    public function tearDown()
    {
        Output::reset();
        /* ... */
    }
}
</code></pre></div>

<p>
    From here, you test as normal -- but when you invoke methods that will
    cause headers or content to emit, you can now test to see what those
    contain:
</p>

<div class="example"><pre><code language="php">
public function testEmitsExpectedHeadersAndContent()
{
    /* ... */

    $this->assertContains('Content-Type: application/json', Output::$headers);
    $json = Output::$body;
    $data = json_decode($json, true);
    $this->assertArrayHasKey('foo', $data);
    $this->assertEquals('bar', $data['foo']);
}
</code></pre></div>

<h2>How it works</h2>

<p>
    Why does this work?
</p>

<p>
    PHP performs some magic when it resolves functions. With classes, it looks
    for a matching class either in the current namespace, or one that was
    imported (and potentially aliased); if a match is not found, it stops, and
    raises an error. With functions, however, it looks first in the current
    namespace, and if it isn't found, then looks in the global namespace. This
    last part is key -- it means that if you redefine a function in the current
    namespace, it will be used in lieu of the original function defined by
    PHP. This also means that any code operating in the same namespace as the 
    function -- even if defined in another file -- will use that function.
</p>

<p>
    This technique just leverages this fact.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>Better Understanding Controllers Through Basic Patterns</title>
      <pubDate>Mon, 09 Jun 2014 17:00:00 +0000</pubDate>
      <link>http://mwop.net/blog/2014-06-09-controllers-as-facades.html</link>
      <guid>http://mwop.net/blog/2014-06-09-controllers-as-facades.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    <a href="http://paul-m-jones.com/">Paul M. Jones</a> has started an interesting
    discussion rethinking the <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>
    pattern as applied to the web, which he has dubbed <a href="https://github.com/pmjones/mvc-refinement">Action-Domain-Responder (ADR)</a>.
    If you haven't given it a read yet, click the link and do that; this page will
    still be sitting here waiting when you return.
</p>

<p>
    I agree with a ton of it &#8212; heck, I've contributed to it a fair bit via conversations
    with Paul. But there's been one thing nagging at me for a bit now, and I was
    finally able to put it into words recently.
</p>

<p>
    Controllers &#8212; Actions in ADR &#8212; can be explained as <em>facades</em>.
</p><h2>Definitions</h2>

<p>
    The design pattern <em>Facade</em> originates in the book "Design Patterns: Elements of Reusable
    Object Oriented Software," written by Erich Gamma, Ralph Johnson, Richard Helm, and John
    Vlissides. Over the years, that book has come to be referred to as the "Gang of Four",
    referring to the four authors, and often abbreviated as "GoF".
</p>

<p>
    The Facade pattern itself is one of the seven structural design patterns defined in the GoF.
    Structural design patterns are those that provide a mechanism for defining the <em>relationships</em>
    between classes or objects in a system. Specifically:
</p>

<blockquote>
    Facade defines a simplifed interface to a complex system.
</blockquote>

<p>
    <a href="http://en.wikipedia.org/wiki/Facade_pattern">Wikipedia has a general entry on the pattern</a>
    as well, and provides some other general characteristics of a Facade:
</p>

<ul>
    <li>A Facade creates a convenience method around a set of operations, thus
        reducing the complexity of operations.</li>
    <li>A Facade reduces the immediate dependencies of the calling code (they call the Facade, not the underlying code).
</ul>

<h2>Facade Example</h2>

<p>
    As an example, let's consider the following workflow:
</p>

<ul>
    <li>Marshal some objects</li>
    <li>Munge some incoming data</li>
    <li>Call a validator</li>
    <li>If the data does not validate, raise an error</li>
    <li>Start a transaction</li>
    <li>Pass data to several different tables</li>
    <li>Commit the transaction</li>
    <li>Log the changes</li>
    <li>Email notifications</li>
</ul>

<p>
    Now, we could just write the code:
</p>

<div class="example"><pre><code language="php">
$db     = new Db($connectionConfig);
$log    = new Logger($loggerConfig);
$mailer = new Mailer($mailerConfig);
$data   = array_merge_recursive($_POST, $_FILES);

$inputFilter = new InputFilter();
$inputFilter->setData($data);
if (! $inputFilter->isValid()) {
    throw new DomainException();
}

$db->transactionStart();
$db->insertInto(/* ... */);
$db->insertInto(/* ... */);
$db->insertInto(/* ... */);
$db->transactionStop();

$log->info('Finished a transaction');
$mailer->send('New transaction')
</code></pre></div>

<p>
    Straight-forward. But imagine if you needed to do this more than once. Or if
    you wanted to re-use this logic in multiple places in your application. This
    is a situation just waiting to go out-of-sync &#8212; and one where developers
    will come to rely on cut-and-paste for doing it correctly.
</p>

<p>
    A facade would wrap this logic:
</p>

<div class="example"><pre><code language="php">
class DataTransaction
{
    protected $db;
    protected $logger;
    protected $mailer;

    public function __construct(Db $db, Logger $logger, Mailer $mailer)
    {
        $this->db     = $db;
        $this->logger = $logger;
        $this->mailer = $mailer;
    }

    public function execute($data)
    {
        $inputFilter = new InputFilter();
        $inputFilter->setData($data);
        if (! $inputFilter->isValid()) {
            throw new DomainException();
        }

        $this->db->transactionStart();
        $this->db->insertInto(/* ... */);
        $this->db->insertInto(/* ... */);
        $this->db->insertInto(/* ... */);
        $this->db->transactionStop();

        $this->logger->info('Finished a transaction');
        $this->mailer->send('New transaction')
    }
}
</code></pre></div>

<p>
    You would then instantiate the facade &#8212; likely using an
    <a href="http://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control</a>
    container to inject the dependencies &#8212; and then invoke it:
</p>

<div class="example"><pre><code language="php">
$dataTransaction->execute(array_merge_recursive($_POST, $_FILES));
</code></pre></div>

<p>
    This code fulfills the Facade pattern: we're no longer directly manipulating dependencies,
    and we've simplified a complex set of operations to a single, unified API.
</p>

<h2>Controllers and Actions</h2>

<p>
    Hopefully you can see where I'm going with this.
</p>

<blockquote>
    Controllers in MVC, and Actions in ADR, are best characterized as Facades.
</blockquote>

<p>
    You can define Controllers or Actions as Facades for the following operations:
</p>

<ul>
    <li>Marshaling arguments from the request.</li>
    <li>Invoking any domain/model logic, using arguments marshaled from the request.</li>
    <li>Marshaling and returning a response/responder.</li>
</ul>

<p>
    I think characterizing Controllers and Actions as Facades has some huge benefits.
    In both <a href="http://blog.astrumfutura.com/archives/373-The-M-in-MVC-Why-Models-are-Misunderstood-and-Unappreciated.html">PHP</a>
    and <a href="https://www.google.com/search?q=fat+controllers+rails">Rails</a>,
    we've witnessed the problems that arise from so-called "Fat Controllers" &#8212;
    controllers that do a ton of work, making them untestable, unreadable, non-reusable
    nightmares. If we think of them as Facades, specifically for the three items
    noted above, we focus on the specific purpose they fulfill within the system,
    giving us:
</p>

<ul>
    <li>Adherence to the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a></li>
    <li>Adherence to the <a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency Inversion Priniciple</a></li>
    <li>Adherence to the <a href="http://en.wikipedia.org/wiki/Law_Of_Demeter">Law of Demeter</a></li>
    <li>Ability to unit test our Controllers and Actions (instead of requiring integration tests with complex configuration and setup)</li>
    <li>The possibility of <a href="http://en.wikipedia.org/wiki/Hierarchical_model%E2%80%93view%E2%80%93controller">hierarchical MVC</a> (usually tacked on, or poorly implemented)</li>
    <li>Clarity of purpose when creating Controllers and Actions (do only those three things)</li>
</ul>

<p>
    Defining them as Facades for these three specific operations means we push logic
    into specific domains, achieving a proper <a href="http://en.wikipedia.org/wiki/Separation_of_concerns">separation of concerns</a>.
    Anything that falls outside those three operations gets pushed elsewhere:
</p>

<ul>
    <li>Models/Domains are invoked with the arguments marshaled from the request. If you find yourself
        calling many models, or manipulating the results returned by models, you need to create
        Facades in your model/domain layer.</li>
    <li>If you find yourself doing lots of work in creating your response, you need to create
        a Facade for marshaling the response (in ADR, that would mean encapsulating more logic
        in your Responder).
</ul>

<p>
    For me, thinking of Controllers and Actions as Facades has an additional benefit:
    it describes rather complex <em>architectural</em> patterns in terms of <em>basic design
    patterns</em>. I find the more I can reduce the complexity of a definition, the more
    likely I will understand and use it correctly.
</p>

<h3>Epilogue</h3>

<p>
    Consider this post a <em>refinement</em> of the MVC and ADR architectural 
    patterns &#8212; a way of describing them in terms of more fundamental design patterns.
</p>

<p>
    Also, this article is littered with links. Click them. Read them. Digest them. Read the books
    they reference. Design and architectural patterns exist because developers observed the
    patterns and gave them names; learn to recognize them and apply them, at all levels of
    your application.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>A Better $state.reload for the AngularJS UI-Router</title>
      <pubDate>Thu, 08 May 2014 17:00:00 +0000</pubDate>
      <link>http://mwop.net/blog/2014-05-08-angular-ui-router-reload.html</link>
      <guid>http://mwop.net/blog/2014-05-08-angular-ui-router-reload.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    While working on <a href="http://apigility.org/">Apigility</a>, several times I ran into
    an odd issue: after fetching new data via an API and assigning it to a scoped variable,
    content would flash into existence... and then disappear. Nothing would cause it to display
    again other than a browser reload of the page.
</p><h2>Setup</h2>

<p>
    I have a page that lists a set of items. When you create an item, you push data to the API,
    and, when done, the new item should be in that list.
</p>

<h2>First try: append to list</h2>

<p>
    My first attempt was just appending the data to the list.
</p>

<div class="example"><pre><code language="javascript">
service.create(data).then(function (newItem) {
    flash.success = 'Successfully created something';
    /* append new item to list */
    $scope.services.push(newItem);
});
</code></pre></div>

<p>
    This worked... until you left that screen and returned. At that point, the 
    new item would be gone, even if I coded my ui-router states to force a cache
    refresh.
</p>

<h2>Refresh list</h2>

<p>
    My next attempt was to write a routine that would do a cache refresh after
    creating the new item.
</p>

<div class="example"><pre><code language="javascript">
service.create(data).then(function (newItem) {
    flash.success = 'Successfully created something';
    service.fetchAll(var force = true).then(function (services) {
        $scope.services = services;
    });
});
</code></pre></div>

<p>
    This is when I started noticing the "flash of content" problem. Essentially, immediately
    after fetching the set of services, you'd see the new item appended... and then it would
    disappear.
</p>

<h2>$state.reload()</h2>

<p>
    At this point, I figured I'd use the ui-router to force a refresh, specifically via
    <code>$state.reload()</code>.
</p>

<div class="example"><pre><code language="javascript">
service.create(data).then(function (newItem) {
    flash.success = 'Successfully created something';
    service.fetchAll(var force = true).then(function (services) {
        $scope.services = services;
        $state.reload();
    });
});
</code></pre></div>

<p>
    I tried both with and without setting the scoped variable. Initially, I thought it was
    working -- but, as it turned out, I missed a case. I tested every single time with at
    least one item already in the list -- and this approach worked. However, when I tried
    with the list not yet populated, failure once again.
</p>

<h2>Success: $timeout</h2>

<p>
    Surprisingly, the least intuitive solution ended up working: introducing a delay.
</p>

<div class="example"><pre><code language="javascript">
service.create(data).then(function (newItem) {
    flash.success = 'Successfully created something';
    service.fetchAll(var force = true)
        .then(function (services) {
            $scope.services = services;
        }).then(function () {
            return $timeout(function () {
                $state.go('.', {}, { reload: true });
            }, 100);
        });
});
</code></pre></div>

<p>
    I have a few things to note about this. First, I moved the "reload" into its own promise. This was done
    to ensure it doesn't block on the scope assignment. Second, I introduce a <code>$timeout</code>
    call. This essentially gives the scope a chance to populate before the reload triggers. Some
    examples I saw did a 1ms timeout; I found in practice that this was not long enough; 100ms was
    long enough, and did not introduce a noticeable delay in UI responsiveness. Finally, you'll
    note this does not use <code>$state.reload()</code>. This is due to discovering that part of my
    problem is a <a href="https://github.com/angular-ui/ui-router/issues/582">known bug in <code>$state.reload()</code></a>,
    whereby state "resolve" configuration is not honored.
</p>

<p>
    I hope this approach helps others -- I've found it to be robust and predictable.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>Apigility: Using RPC with HAL</title>
      <pubDate>Wed, 26 Mar 2014 20:30:00 +0000</pubDate>
      <link>http://mwop.net/blog/2014-03-26-apigility-rpc-with-hal.html</link>
      <guid>http://mwop.net/blog/2014-03-26-apigility-rpc-with-hal.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    A few days ago, we <a href="http://bit.ly/ag-1-beta1">released our first beta of Apigility</a>.
    We've started our documentation effort now, and one question has arisen a few times that I
    want to address: How can you use Hypermedia Application Language (HAL) in RPC services?
</p><h2>HAL?</h2>

<p>
    <a href="http://tools.ietf.org/html/draft-kelly-json-hal-06">Hypermedia Application Language</a>
    is an IETF proposal for how to represent resources and their relations within APIs. Technically,
    it provides two mediatypes, <code>application/hal+json</code> and <code>application/hal+xml</code>;
    however, Apigility only provides the JSON variant.
</p>

<p>
    The important things to know about HAL are:
</p>

<ul>
    <li>
        <p>
            It provides a standard way of describing relational links. All relational
            links are under a <code>_links</code> property of the resource. That property
            is an object. Each property of that object is a link relation; the value of
            each link relation is an object (or array of such objects) describing the link
            that must minimally contain an <code>href</code> proerty. The link object
            itself can contain some additional metadata, such as a mediatype, a name
            (useful for differentiating between multiple link objects assigned to the same
            relation).
        </p>

        <p>
            While not required, the specification recommends resources contain a "self"
            relational link, indicating the canonical location for the resource. This
            is particularly useful when we consider embedding (the next topic).
        </p>

        <p>
            Sound hard? It's not:
        </p>

        <div class="example"><pre><code language="javascript">
{
    "_links": {
        "self": {
            "href": "/blog/2014-03-26-apigility-rpc-with-hal"
        }
    }
}
        </code></pre></div>
    </li>

    <li>
        <p>
            Besides link relations, HAL also provides a standard way of describing
            <em>embedded resources</em>. An embedded resource is any other resource
            you can address via your API, and, as such, would be structured as a HAL
            resource -- in other words, it would have a <code>_links</code> property
            with relational links. Essentially, any property of the resource you're
            returning that can itself be addressed via the URI must be <em>embedded</em>
            in the resource. This is done via the property <code>_embedded</code>.
        </p>

        <p>
            Like <code>_links</code>, <code>_embedded</code> is an object. Each key in the
            object is the local name by which the resource refers to the embedded resource.
            The value of such keys can either be HAL resources or <em>arrays</em> of HAL
            resources; in fact, this is how <em>collections</em> are represented in HAL!
        </p>

        <p>
            As examples:
        </p>

        <div class="example"><pre><code language="javascript">
{
    "_links": {
        "self": {
            "href": "/blog/2014-03-26-apigility-rpc-with-hal"
        }
    },
    "_embedded": {
        "author": {
            "_links": {
                "self": {
                    "href": "/blog/author/matthew"
                }
            },
            "id": "matthew",
            "name": "Matthew Weier O'Phinney",
            "url": "http://mwop.net"
        },
        "tags": [
            {
                "_links": {
                    "self": {
                        "href": "/blog/tag/php"
                    }
                },
                "id": "php"
            },
            {
                "_links": {
                    "self": {
                        "href": "/blog/tag/rest"
                    }
                },
                "id": "rest"
            }
        ]
    }
}
        </code></pre></div>

        <p>
            The example above shows two embedded resources. The first is the author;
            the second, a collection of tags. Note that <em>every</em> object
            under <code>_embedded</code> is a HAL object!
        </p>

        <p>
            You can go quite far with this -- you can also have embedded resources
            inside your embedded resources, arbitrarily deep.
        </p>
    </li>
</ul>

<h2>RPC?</h2>

<p>
    RPC stands for Remote Procedure Call, and, when describing a web API, is 
    usually used to describe a web service that publishes multiple method calls 
    at a single URI using only <code>POST</code>; XML-RPC and SOAP are the
    usual suspects.
</p>

<p>
    In Apigility, we use the term RPC in a much looser sense; we use it to describe
    one-off services: actions like "authenticate," or "notify," or "register" 
    would all make sense here. They are actions that usually only need to respond
    to a single HTTP method, and which may or may not describe a "thing", which
    is what we usually consider a "resource" when discussing REST terminology.
</p>

<p>
    That said: what if what we want to return from the RPC call <em>are</em> REST
    resources?
</p>

<h2>Returning HAL from RPC Services</h2>

<p>
    In order to return HAL from RPC services, we need to understand (a) how 
    Content Negotiation works, and (b) what needs to be returned in order for the
    HAL renderer to be able to create a representation.
</p>

<p>
    For purposes of this example, I'm positing a <code>RegisterController</code> as
    an RPC service that, on success, is returning a <code>User</code> object 
    that I want rendered as a HAL resource.
</p>

<p>
    The <a href="https://github.com/zfcampus/zf-content-negotiation">zf-content-negotiation</a>
    module takes care of content negotiation for Apigility. It introspects the <code>Accept</code>
    header in order to determine if we can return a representation, and then, if it can, will
    cast any <code>ZF\ContentNegotiation\ViewModel</code> returned from a controller to the
    appropriate view model for the representation. From there, a renderer will pick up the view
    model and do what needs to be done.
</p>

<p>
    So, the first thing we have to do is return <code>ZF\ContentNegotiation\ViewModel</code>
    instances from our controller.
</p>

<div class="example"><pre><code language="php">
use Zend\Mvc\Controller\AbstractActionController;
use ZF\ContentNegotiation\ViewModel;

class RegisterController extends AbstractActionController
{
    public function registerAction()
    {
        /* ... do some work ... get a user ... */
        return new ViewModel(array('user' => $user));
    }
}
</code></pre></div>

<p>
    The <a href="https://github.com/zfcampus/zf-hal">zf-hal</a> module in Apigility
    creates the actual HAL representations. <code>zf-hal</code> looks for a "payload" variable in
    the view model, and expects that value to be either a <code>ZF\Hal\Entity</code>
    (single item) or <code>ZF\Hal\Collection</code>. When creating an <code>Entity</code>
    object, you need the object being represented, as well as the identifier. 
    So, let's update our return value.
</p>

<div class="example"><pre><code language="php">
use Zend\Mvc\Controller\AbstractActionController;
use ZF\ContentNegotiation\ViewModel;
use ZF\Hal\Entity;

class RegisterController extends AbstractActionController
{
    public function registerAction()
    {
        /* ... do some work
         * ... get a $user
         * ... assume we have also now have an $id
         */
        return new ViewModel(array('payload' => array(
            'user' => new Entity($user, $id),
        )));
    }
}
</code></pre></div>

<p>
    <code>zf-hal</code> contains what's called a "metadata map". This is a map of classes to
    information on how <code>zf-hal</code> should render them: what route to use, what additional
    relational links to inject, how to serialize the object, what field represents
    the identifier, etc.
</p>

<p>
    In most cases, you will have likely already defined a REST service for the
    resource you want to return from the RPC service, in which case you will
    be done. However, if you want, you can go in and manually configure
    the metadata map in your API module's <code>config/module.config.php</code>
    file:
</p>

<div class="example"><pre><code language="php">
return array(
    /* ... */
    'zf-hal' => array(
        'metadata_map' => array(
            'User' => array(
                'route_name' => 'api.rest.user',
                'entity_identifier_name' => 'username',
                'route_identifier_name' => 'user_id',
                'hydrator' => 'Zend\Stdlib\Hydrator\ObjectProperty',
            ),
        ),
    ),
);
</code></pre></div>

<p>
    Finally, we need to make sure that the service is configured to actually return
    HAL. We can do this in the admin if we want. Find the "Content Negotiation" section
    of the admin, and the "Content Negotiation Selector" item, and set that to "HalJson";
    don't forget to save! Alternately, you can do this manually in the API module's 
    <code>config/module.config.php</code> file, under the <code>zf-content-negotiation</code>
    section:
</p>

<div class="example"><pre><code language="php">
return array(
    /* ... */
    'zf-content-negotiation' => array(
        'controllers' => array(
            /* ... */
            'RegisterController' => 'HalJson',
        ),
        /* ... */
    ),
);
</code></pre></div>

<p>
    Once your changes are complete, when you make a successful request to the URI
    for your "register" RPC service, you'll receive a HAL response pointing to the
    canonical URI for the user resource created!
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>A Bower Primer</title>
      <pubDate>Tue, 03 Dec 2013 15:50:00 +0000</pubDate>
      <link>http://mwop.net/blog/2013-12-03-bower-primer.html</link>
      <guid>http://mwop.net/blog/2013-12-03-bower-primer.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    Recently, I've been doing a fair bit of frontend development with my team 
    as we've worked on the <a href="http://apigility.org/">Apigility</a> admin.
    This has meant working with a variety of both JavaScript and CSS
    libraries, often trying something out only to toss it out again later.
    Working with frontend libraries has been quite a hassle, due to a combination
    of discovery, installation issues, and build issues (minimization, primarily).
    I figured there must a better way.
</p><h2>Background</h2>

<p>
    Until recently, discovery of JS and CSS libraries has gone something like this:
</p>

<ol>
    <li>Search for functionality via Google</li>
    <li>Generally find a solution on StackOverflow</li>
    <li>Discover said solution relies on a third-party library</li>
    <li>Google for said library</li>
    <li>Generally find said library on GitHub</li>
    <li>Clone the library locally</li>
    <li>Either build the final assets, or try and locate them in the repo</li>
    <li>Minimize the assets</li>
    <li>Copy the assets into the project</li>
</ol>

<p>
    Frontend development sucks.
</p>

<p>
    Then I started noticing these files called <code>.bowerrc</code> and 
    <code>bower.json</code> in many of the aforementioned libraries, and also
    that <a href="http://ralphschindler.com/">Ralph</a> had put some inside our
    Apigility skeleton. I got curious as to what this "bower" might be.
</p>

<h2>Bower: Package management for the web</h2>

<p>
    Essentially, <a href="http://bower.io/">Bower</a> is, to use the project's
    words, "a package manager for the web." Written in JavaScript, and running
    on <a href="http://nodejs.org/">node.js</a>, it is to frontend assets what
    <a href="https://npmjs.org/">npm</a> is to node, or <a href="https://getcomposer.org">Composer</a> 
    is to PHP. It allows you to define what assets you need in your application,
    including the versions, and then install them. If any of those assets have
    other dependencies, those, too, will be installed.
</p>

<p>
    Later, you can update the dependencies, add or remove dependencies, and more.
</p>

<p>
    On top of that, bower allows you to <em>search</em> for packages, which
    essentially allows you to eliminate most of the steps 4 and on in my list
    above.
</p>

<h2>A Bower Primer</h2>

<p>So, how do you use bower?</p>

<p>
    In my experience, which is not extensive by any stretch, the usage is like this:
</p>

<ol>
    <li>Search for functionality via Google</li>
    <li>Generally find a solution on StackOverflow</li>
    <li>Discover said solution relies on a third-party library</li>
    <li>Use bower to search for said library</li>
    <li>Add the discovered library to your <code>bower.json</code> file</li>
    <li>Run <code>bower install</code> or <code>bower update</code></li>
</ol>

<p>
    I've found that most projects registered with bower have minimized builds
    available (as well as the full source build), which is a huge boon in
    terms of performance. It also eliminates the "minimize the assets" step from
    my original list.
</p>

<p>
    To use bower, you'll need two files. The first is <code>.bowerrc</code> 
    which goes in your project root; you'll run <code>bower</code> from this 
    same directory.  This file tells bower how to run, and where to install 
    things, and, despite being an RC file, is written in JSON. Mine usually 
    looks like this:
</p>

<div class="example"><pre><code language="javascript">
{
    "directory": "public/assets/vendor"
}
</code></pre></div>

<p>
    The above tells bower to install dependencies in the <code>public/assets/vendor</code>
    subdirectory.
</p>

<p>
    The second file you need is <code>bower.json</code>. This file tells bower
    what asset packages you want to install, and the preferred version. (The file
    can also be used to define a package, just like with Composer or npm.) As an
    example, the following is a definition I used for an Apigility example:
</p>

<div class="example"><pre><code language="javascript">
{
    "name": "ag-contacts-demo",
    "version": "0.0.1",
    "ignore": [
        "**/.*"
    ],
    "dependencies": {
        "angular": "~1.2",
        "angular-resource": "~1.2",
        "angular-route": "~1.2",
        "bootstrap": ">=3.0.0",
        "font-awesome": "~3.2.1"
    }
}
</code></pre></div>

<p>
    Bower requires that packages use <a href="http://semver.org/">Semantic
    Versioning</a>. You can specify exact versions, minor versions, or major
    versions, combine them with comparison operators (<code>&lt;</code>, 
    <code>&gt;</code>, <code>=</code>, etc.), or use the "next significant release"
    operator ("~") to indicate a given version up to the next more general
    release (e.g., "~1.2" is equivalent to "&gt;=1.2,&lt;2.0").
</p>

<p>
    Once you have these defined, you should also add an entry to your 
    <code>.gitignore</code> file to exclude the directory you list in your
    <code>.bowerrc</code>; these files can be installed at build time,
    and thus help you keep your project repository lean. Per the above
    example:
</p>

<div class="example"><pre><code language="text">
public/assets/vendor/
</code></pre></div>

<p>
    At this point, run <code>bower install</code>, and bower will resolve
    all dependencies and install them where you want.
</p>

<p>
    At any point, you can list what packages bower has installed, as well
    as the versions it has installed. The <code>bower help</code> command
    is your friend should those needs arise.
</p>

<h2>Closing Thoughts</h2>

<p>
    I'm quite happy with the various tools emerging to make modern
    web development easier by allowing developers to more easily
    share their work, as well as ensure that all dependencies are
    easily installable. Bower is another tool in my arsenal as a web
    developer, giving me a consistent set of dependency management tools from my 
    server-side development all the way to my client-side application.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>RESTful APIs with ZF2, Part 3</title>
      <pubDate>Mon, 25 Feb 2013 12:29:00 +0000</pubDate>
      <link>http://mwop.net/blog/2013-02-25-restful-apis-with-zf2-part-3.html</link>
      <guid>http://mwop.net/blog/2013-02-25-restful-apis-with-zf2-part-3.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    In my <a href="/blog/2013-02-11-restful-apis-with-zf2-part-1.html">previous</a> 
    <a href="/blog/2013-02-13-restful-apis-with-zf2-part-2.html">posts</a>, I 
    covered basics of JSON hypermedia APIs using Hypermedia Application Language
    (HAL), and methods for reporting errors, including API-Problem and vnd.error.
</p>

<p>
    In this post, I'll be covering <em>documenting</em> your API -- techniques 
    you can use to indicate what HTTP operations are allowed, as well as convey 
    the full documentation on what endpoints are available, what they accept, 
    and what you can expect them to return.
</p>

<p>
    While I will continue covering general aspects of RESTful APIs in this 
    post, I will also finally introduce several ZF2-specific techniques.
</p><h2>Why Document?</h2>

<p>
    If you're asking this question, you've either never consumed software, or
    your software is perfect and self-documenting. I frankly don't believe 
    either one.
</p>

<p>
    In the case of APIs, those consuming the API need to know how to use it. 
</p>

<ul>
    <li>What endpoints are available? Which operations are available for each endpoint?</li>
    <li>What does each endpoint expect as a payload during the request?</li>
    <li>What can you expect as a payload in return?</li>
    <li>How will errors be communicated?</li>
</ul>

<p>
    While the promise of hypermedia APIs is that each response tells you the
    next steps available, you still, somewhere along the way, need more
    information - what payloads look like, which HTTP verbs should be used,
    and more. If you're <strong>not</strong> documenting your API, you're
    "doing it wrong."
</p>

<h2>Where Should Documentation Live?</h2>

<p>
    This is the much bigger question.
</p>

<p>
    Of the questions I raised above, detailing what should be documented, there
    are two specific types. When discussing what operations are available, 
    we have a technical solution in the form of the <code>OPTIONS</code>
    method and its counterpart, the <code>Allow</code> header. Everything
    else falls under end-user documentation.
</p>

<h2>OPTIONS</h2>

<p>
    The HTTP specification details the <code>OPTIONS</code> method as 
    idempotent, non-cacheable, and for use in detailing what operations
    are available for the given resource specified by the request URI. It
    makes specific mention of the <code>Allow</code> header, but does not
    limit what is returned for requests made via this method.
</p>

<p>
    The <code>Allow</code> header details the allowed HTTP methods for the
    given resource.
</p>

<p>
    Used in combination, you make an <code>OPTIONS</code> request to a URI,
    and it should return a response containing an <code>Allow</code> header;
    from that header value, you then know what other HTTP methods can be made
    to that URI.
</p>

<p>
    What this tells us is that our RESTful endpoint should do the following:
</p>

<ul>
    <li>
        When an <code>OPTIONS</code> request is made, return a response with
        an <code>Allow</code> header that has a list of the available HTTP
        methods allowed.
    </li>

    <li>
        For any HTTP method we do <em>not</em> allow, we should return a
        "405 Not Allowed" response.
    </li>
</ul>

<p>
    These are fairly easy to accomplish in ZF2. <em>(See? I promised I'd
    get to some ZF2 code in this post!)</em>
</p>

<p>
    When creating RESTful endpoints in ZF2, I recommend using
    <code>Zend\Mvc\Controller\AbstractRestfulController</code>. This controller
    contains an <code>options()</code> method which you can use to respond to
    an <code>OPTIONS</code> request. As with any ZF2 controller, returning
    a response object will prevent rendering and bubble out immediately so
    that the response is returned.
</p>

<div class="example"><pre><code language="php">
namespace My\Controller;
use Zend\Mvc\Controller\AbstractRestfulController;

class FooController extends AbstractRestfulController
{
    public function options()
    {
        $response = $this->getResponse();
        $headers  = $response->getHeaders();

        // If you want to vary based on whether this is a collection or an
        // individual item in that collection, check if an identifier from
        // the route is present
        if ($this->params()->fromRoute('id', false)) {
            // Allow viewing, partial updating, replacement, and deletion
            // on individual items
            $headers->addHeaderLine('Allow', implode(',', array(
                'GET',
                'PATCH',
                'PUT',
                'DELETE',
            )));
            return $response;
        }

        // Allow only retrieval and creation on collections
        $headers->addHeaderLine('Allow', implode(',', array(
            'GET',
            'POST',
        )));
        return $response;
    }
}
</code></pre></div>

<p>
    The next trick is returning the 405 response if an invalid option is used.
    For this, you can create a listener in your controller, and wire it to 
    listen at higher-than-default priority. As an example:
</p>

<div class="example"><pre><code language="php">
namespace My\Controller;
use Zend\EventManager\EventManagerInterface;
use Zend\Mvc\Controller\AbstractRestfulController;

class FooController extends AbstractRestfulController
{
    protected $allowedCollectionMethods = array(
        'GET',
        'POST',
    );

    protected $allowedResourceMethods = array(
        'GET',
        'PATCH',
        'PUT',
        'DELETE',
    );

    public function setEventManager(EventManagerInterface $events)
    {
        parent::setEventManager($events);
        $events->attach('dispatch', array($this, 'checkOptions'), 10);
    }

    public function checkOptions($e)
    {
        $matches  = $e->getRouteMatch();
        $response = $e->getResponse();
        $request  = $e->getRequest();
        $method   = $request->getMethod();

        // test if we matched an individual resource, and then test
        // if we allow the particular request method
        if ($matches->getParam('id', false)) {
            if (!in_array($method, $this->allowedResourceMethods)) {
                $response->setStatusCode(405);
                return $response;
            }
            return;
        }

        // We matched a collection; test if we allow the particular request 
        // method
        if (!in_array($method, $this->allowedCollectionMethods)) {
            $response->setStatusCode(405);
            return $response;
        }
    }
}
</code></pre></div>

<p>
    Note that I moved the allowed methods into properties; if I did the above,
    I'd refactor the <code>options()</code> method to use those properties as
    well to ensure they are kept in sync.
</p>

<p>
    Also note that in the case of an invalid method, I return a response object.
    This ensures that nothing else needs to execute in the controller; I
    discover the problem and return early.
</p>

<h2>End-User Documentation</h2>

<p>
    Now that we have the technical solution out of the way, we're still left 
    with the bulk of the work left to accomplish: providing end-user 
    documentation detailing the various payloads, errors, etc.
</p>

<p>
    I've seen two compelling approaches to this problem. The first builds on
    the <code>OPTIONS</code> method, and the other uses a hypermedia link in
    every response to point to documentation.
</p>

<p>
    The <code>OPTIONS</code> solution is this: <a 
    href="http://zacstewart.com/2012/04/14/http-options-method.html">use the 
    body of an <code>OPTIONS</code> response to provide documentation</a>.
    (Keith Casey <a href="http://vimeo.com/49613738">gave an excellent short 
    presentation about this at REST Fest 2012</a>).
</p>

<p>
    The <code>OPTIONS</code> method allows for you to return a body in the
    response, and also allows for content negotiation. The theory, then, is
    that you return media-type-specific documentation that details the
    methods allowed, and what they specifically accept in the body. While
    there is no standard for this at this time, the first article I linked
    suggested including a description, the parameters expected, and one or more 
    example request bodies for each HTTP method allowed; you'd likely also
    want to detail the responses that can be expected.
</p>

<div class="example"><pre><code language="javascript">
{
    "POST": {
        "description": "Create a new status",
        "parameters": {
            "type": {
                "type": "string",
                "description": "Status type -- text, image, or url; defaults to text",
                "required": false
            },
            "text": {
                "type": "string",
                "description": "Status text; required for text types, optional for others",
                "required": false
            },
            "image_url": {
                "type": "string",
                "description": "URL of image for image types; required for image types",
                "required": false
            },
            "link_url": {
                "type": "string",
                "description": "URL of image for link types; required for link types",
                "required": false
            }
        },
        "responses": [
            {
                "describedBy": "http://example.com/problems/invalid-status",
                "title": "Submitted status was invalid",
                "detail": "Missing text field required for text type"
            },
            {
                "id": "abcdef123456",
                "type": "text",
                "text": "This is a status update",
                "timestamp": "2013-02-22T10:06:05+0:00"
            }
        ],
        "examples": [
            {
                "text": "This is a status update"
            },
            {
                "type": "image",
                "text": "This is the image caption",
                "image_url": "http://example.com/favicon.ico"
            },
            {
                "type": "link",
                "text": "This is a description of the link",
                "link_url": "http://example.com/"
            },
        ]
    }
}
</code></pre></div>

<p>
    If you were to use this methodology, you would alter the 
    <code>options()</code> method such that it does not return a response
    object, but instead return a view model with the documentation.
</p>

<div class="example"><pre><code language="php">
namespace My\Controller;
use Zend\Mvc\Controller\AbstractRestfulController;

class FooController extends AbstractRestfulController
{
    protected $viewModelMap = array(/* ... */);

    public function options()
    {
        $response = $this->getResponse();
        $headers  = $response->getHeaders();

        // Get a view model based on Accept types
        $model    = $this->acceptableViewModelSelector($this->viewModelMap);

        // If you want to vary based on whether this is a collection or an
        // individual item in that collection, check if an identifier from
        // the route is present
        if ($this->params()->fromRoute('id', false)) {
            // Still set the Allow header
            $headers->addHeaderLine('Allow', implode(
                ',', 
                $this->allowedResourceMethods
            ));

            // Set documentation specification as variables
            $model->setVariables($this->getResourceDocumentationSpec());
            return $model;
        }

        // Allow only retrieval and creation on collections
        $headers->addHeaderLine('Allow', implode(
            ',',
            $this->allowedCollectionMethods
        ));
        $model->setVariables($this->getCollectionDocumentationSpec());
        return $model;
    }
}
</code></pre></div>

<p>
    I purposely didn't provide the implementations of the 
    <code>getResourceDocumentationSpec()</code> and 
    <code>getCollectionDocumentationSpec()</code> methods, as that will likely
    be highly specific to your application. Another possibility is to use
    your view engine for this, and specify a template file that has the
    fully-populated information. This would require a custom renderer when
    using JSON or XML, but is a pretty easy solution.
</p>

<p>
    <strong>However, there's one cautionary tale to tell</strong>, something I 
    already mentioned: <code>OPTIONS</code>, per the specification, is 
    <em>non-cacheable</em>.  What this means is that everytime somebody makes an 
    <code>OPTIONS</code> request, any cache control headers you provide will be 
    ignored, which means hitting the server for each and every request to the 
    documentation.  Considering documentation is static, this is problematic; 
    it has even prompted <a href="http://www.mnot.net/blog/2012/10/29/NO_OPTIONS">blog 
    posts urging you not to use OPTIONS for documentation</a>.
</p>

<p>
    Which brings us to the second solution for end-user documentation: a static
    page referenced via a hypermedia link.
</p>

<p>
    This solution is insanely easy: you simply provide a <code>Link</code>
    header in your response, and provide a <code>describedby</code> reference
    pointing to the documentation page:
</p>

<div class="example"><pre><code language="http">
Link: &lt;http://example.com/api/documentation.md&gt;; rel="describedby"
</code></pre></div>

<p>
    With ZF2, this is trivially easy to accomplish: create a route and endpoint
    for your documentation, and then a listener on your controller that adds
    the <code>Link</code> header to your response.
</p>

<p>
    The latter, adding the link header, might look like this:
</p>

<div class="example"><pre><code language="php">
namespace My\Controller;
use Zend\EventManager\EventManagerInterface;
use Zend\Mvc\Controller\AbstractRestfulController;

class FooController extends AbstractRestfulController
{
    public function setEventManager(EventManagerInterface $events)
    {
        parent::setEventManager($events);
        $events->attach('dispatch', array($this, 'injectLinkHeader'), 20);
    }

    public function injectLinkHeader($e)
    {
        $response = $e->getResponse();
        $headers  = $response->getHeaders();
        $headers->addHeaderLine('Link', sprintf(
            '<%s>; rel="describedby"', 
            $this->url('documentation-route-name')
        ));
    }
}
</code></pre></div>

<p>
    If you want to ensure you get a fully qualified URL that includes the 
    schema, hostname, and port, there are a number of ways to do that as
    well; the above gives you the basic idea.
</p>

<p>
    Now, for the route and endpoint, there are tools that will help you
    simplify that task as well, in the form of a couple of ZF2 modules:
    <a href="https://github.com/weierophinney/PhlySimplePage">PhlySimplePage</a>
    and <a href="https://github.com/Soflomo/Prototype">Soflomo\Prototype</a>.
    <em>(Disclosure: I'm the author of PhlySimplePage.)</em>
</p>

<p>
    Both essentially allow you to specify a route and the corresponding
    template name to use, which means all you need to do is provide a little
    configuration, and a view template. <code>Soflomo\Prototype</code> has
    slightly simpler configuration, so I'll demonstrate it here:
</p>

<div class="example"><pre><code language="php">
return array(
    'soflomo_prototype' => array(
        'documentation-route-name' => array(
            'route'    => '/api/documentation',
            'template' => 'api/documentation',
        ),
    ),
    'view_manager' => array(
        'template_map' => array(
            'api/documentation' => __DIR__ . '/../view/api/documentation.phtml',
        ),
    ),
);
</code></pre></div>

<p>
    I personally have been using the <code>Link</code> header solution, as it's
    so simple to implement. It does <em>not</em> write the documentation for you,
    but thinking about it early and implementing it helps ensure you at least
    start writing the documentation, and, if you open source your project,
    you may find you have users who will write the documentation for you if
    they know where it lives.
</p>

<h2>Conclusions</h2>

<p>
    Document your API, or either nobody will use it, or all you're hear are
    complaints from your users about having to guess constantly about how to
    use it. Include the following information:
</p>

<ul>
    <li>What endpoint(s) is (are) available.</li>
    <li>Which operations are available for each endpoint.
        <ul>
            <li>What payloads are expected by the endpoint.</li>
            <li>What payloads can a user expect in return.</li>
            <li>What media types may be used for requests.</li>
            <li>What media types may be expected in responses.</li>
        </ul>
    </li>
</ul>

<p>
    Additionally, make sure that you do the <code>OPTIONS</code>/<code>Allow</code>
    dance; don't just accept any request method, and report the standard
    405 response for methods that you will not allow. Make sure you differentiate
    these for collections versus individual resources, as you likely may
    allow replacing or updating an individual resource, but likely will not
    want to do the same for a whole collection!
</p>

<h2>Next time</h2>

<p>
    So far, I've covered the basics of RESTful JSON APIS, specifically 
    recommending Hypermedia Application Language (HAL) for providing hypermedia
    linking and relations. I've covered error reporting, and provided two
    potential formats (API-Problem and vnd.error) for use with your APIs.
    Now, in this article, I've shown a bit about documenting your API both
    for machine consumption as well as end-users. What's left?
</p>

<p>
    In upcoming parts, I'll talk about ZF2's <code>AbstractRestfulController</code>
    in more detail, as well as how to perform some basic content negotiation.
    I've also had requests about how one might deal with API versioning, and will
    attempt to demonstrate some techniques for doing that as well. Finally,
    expect to see a post showing how I've tied all of this together in a 
    general-purpose ZF2 module so that you can ignore all of these posts and simply
    start writing APIs.
</p>

<h3>Updates</h3>

<p>
    <em>Note: I'll update this post with links to the other posts in the series 
    as I publish them.</em>
</p>

<ul>
    <li><a href="/blog/2013-02-11-restful-apis-with-zf2-part-1.html">Part 1</a></li>
    <li><a href="/blog/2013-02-13-restful-apis-with-zf2-part-2.html">Part 2</a></li>
</ul>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>RESTful APIs with ZF2, Part 2</title>
      <pubDate>Wed, 13 Feb 2013 13:40:00 +0000</pubDate>
      <link>http://mwop.net/blog/2013-02-13-restful-apis-with-zf2-part-2.html</link>
      <guid>http://mwop.net/blog/2013-02-13-restful-apis-with-zf2-part-2.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    In my <a href="/blog/2013-02-11-restful-apis-with-zf2-part-1.html">last post</a>,
    I covered some background on REST and the Richardson Maturity Model, and some
    emerging standards around hypermedia APIs in JSON; in particular, I outlined
    aspects of Hypermedia Application Language (HAL), and how it can be used to
    define a generic structure for JSON resources.
</p>

<p>
    In this post, I cover an aspect of RESTful APIs that's often overlooked:
    reporting problems.
</p><h2>Background</h2>

<p>
    APIs are useful when they're working. But when they fail, they're only 
    useful if they provide us with meaningful information; if all I get is
    a status code, and no indication of what caused the issue, or where I might
    look for more information, I get frustrated.
</p>

<p>
    In consuming APIs, I've come to the following conclusions:
</p>

<ul>
    <li>
        Error conditions need to provide detailed information as to what went 
        wrong, and what steps I may be able to take next. An error code with
        no context gives me nothing to go on.
    </li>

    <li>
        Errors need to be reported consistently. Don't report the error one way
        one time, and another way the next.
    </li>

    <li>
        <strong>DO</strong> use HTTP status codes to indicate an error happened.
        Nothing is more irksome than getting back a 200 status with an error 
        payload.
    </li>

    <li>
        Errors should be reported in a format I have indicated I will Accept 
        (as in the HTTP header). Perhaps the only think more irksome than a 200
        status code for an error is getting back an HTML page when I expect 
        JSON.
    </li>
</ul>

<h2>Why Status Codes Aren't Enough</h2>

<p>
    Since REST leverages and builds on HTTP, an expedient solution for reporting
    problems is to simply use <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">HTTP status codes</a>. 
    These are well understood by web developers, right?
</p>

<p>
    <code>4xx</code> error codes are errors made by the requestor, and are actually fairly 
    reasonable to use for reporting things such as lack of authorization tokens,
    incomplete requests, unsupportable operations, or non-supported media types.
</p>

<p>
    But what happens when the error is on the server - because something has
    gone wrong such as inability to reach your persistence layer or credential
    storage? The <code>5xx</code> series of status codes is sparse and wholly unsuited to
    reporting errors of these types -- <em>though you'll likely still want to use
    a <code>500</code> status to report the failure</em>. But what do you present to the consumer
    so that they know whether or not to try again, or what to report to you
    so that you can fix the issue?
</p>

<p>
    A status code simply isn't enough information most of the time. Yes, you 
    want to define standard status codes so that your clients can perform
    reasonable branching, but you also need a way to communicate <em>details</em>
    to the end-user, so that they can log the information for themselves, display
    information to their own end-users, and/or report it back to you so you can
    do something to resolve the situation.
</p>

<h2>Custom Media Types</h2>

<p>
    The first step is to use a custom media type. Media types are typically 
    both a name as well as a structure -- and the latter is what we're after
    when it comes to error reporting. 
</p>

<p>
    If we return a response using this media type, the client then knows how
    to parse it, and can then process it, log it, whatever.
</p>

<p>
    Sure, you can make up your own format -- as long as you are consistent
    in using it, and you document it. But personally, I don't like inventing
    new formats when standard formats exist already. Custom formats mean that 
    custom clients are required for working with the services; using a standard
    format can save effort and time.
</p>

<p>
    In the world of JSON, I've come across two error media types that appear to
    be gaining traction: <code>application/api-problem+json</code> and 
    <code>application/vnd.error+json</code>
</p>

<h3>API-Problem</h3>

<p>
    This particular media type is <a 
    href="http://tools.ietf.org/html/draft-nottingham-http-problem-02">via the 
    IETF</a>. Like HAL, it provides formats in both JSON and XML, making it 
    a nice cross-platform choice.
</p>

<p>
    As noted already, the media type is <code>application/api-problem+json</code>.
    The representation is a single resource, with the following properties:
</p>

<ul>
    <li>
        <strong>describedBy</strong>: a URL to a document describing the error condition (required)
    </li>

    <li>
        <strong>title</strong>: a brief title for the error condition (required)
    </li>

    <li>
        <strong>httpStatus</strong>: the HTTP status code for the current request (optional)
    </li>

    <li>
        <strong>detail</strong>: error details specific to this request (optional)
    </li>

    <li>
        <strong>supportId</strong>: a URL to the specific problem occurrence (e.g., to a log message) (optional)
    </li>
</ul>

<p>
    As an example:
</p>

<div class="example"><pre><code language="http">
HTTP/1.1 500 Internal Error
Content-Type: application/api-problem+json

{
    "describedBy": "http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html",
    "detail": "Status failed validation",
    "httpStatus": 500,
    "title": "Internal Server Error"
}
</code></pre></div>

<p>
    The specification allows a large amount of flexibility -- you can have your 
    own custom error types, so long as you have a description of them to link 
    to. You can provide as little or as much detail as you want, and even 
    decide what information to expose based on environment.
</p>

<p>
    I personally like to point to the HTTP status code definitions, and then 
    provide request-specific detail; I find this gives quick and simple results 
    that I can later shape as I add more detail to my API. However, the 
    specification definitely encourages you to have unique error types with 
    discrete URIs that describe them -- never a bad thing when creating APIs.
</p>

<h3>vnd.error</h3>

<p>
    This is a <a href="https://github.com/blongden/vnd.error">proposed media 
    type</a> within the HAL community. Like HAL, it provides formats in both 
    JSON and XML, making it a nice cross-platform choice.
</p>

<p>
    It differentiates from API-Problem in a few ways. First, it allows, and 
    even encourages, reporting collections of errors. If you consider PHP 
    exceptions and the fact that they support "previous" exceptions, this is a 
    powerful concept; you can report the entire chain of errors that led to the 
    response.  Second, it encourages pushing detail out of the web service; 
    errors include a "logRef" property that points to where the error detail lives. 
    This is probably better illustrated than explained.
</p>

<p>
    The response payload is an array of objects. Each object has the following 
    members:
</p>

<ul>
    <li>
        <strong>logRef</strong>: a unique identifier for the specific error which can then be
        used to identify the error within server-side logs (required)
    </li>

    <li>
        <strong>message</strong>: the error message itself (required)
    </li>

    <li>
        <strong>_links</strong>: HAL-compatible links. Typically, "help", "describes", and/or 
        "describedBy" relations will be defined here.
    </li>
</ul>

<p>
    As an example, let's consider the API-Problem example I had earlier, and
    provide a vnd.error equivalent:
</p>

<div class="example"><pre><code language="http">
HTTP/1.1 500 Internal Error
Content-Type: application/vnd.error+json

[
    {
        "logRef": "someSha1HashMostLikely",
        "message": "Status failed validation",
        "_links": {
            "describedBy": {"href": "http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html"}
        }
    }
]
</code></pre></div>

<p>
    vnd.error basically begs you to create custom error types, with documentation 
    end-points that detail the source of the error and what you can do about it 
    (this is true of API-Problem as well).
</p>

<p>
    The requirement to include a log reference ("logRef") and have it be unique 
    can be a stumbling block to implementation, however, as it requires effort 
    for uniquely identifying requests, and logging. However, both the 
    identification and logging can be automated.
</p>

<h2>Summary</h2>

<p>
    Error reporting in APIs is as important as the normal resource payloads 
    themselves. Without good error reporting, when an API raises errors, 
    clients have difficulty understanding what they can do next, and cannot
    provide you, the API provider, with information that will allow you to
    debug on the server side.
</p>

<p>
    As noted at the beginning of the article, if you follow the rules below,
    you'll make consumers of your API happier and more productive.
</p>

<ul>
    <li>
        <strong>DO</strong> use appropriate HTTP status codes to indicate an 
        error happened.
    </li>

    <li>
        Report errors in a format I have indicated I will Accept 
        (as in the HTTP header). 
    </li>
    <li>
        Report errors consistently. Don't report the error one way one time, 
        and another way the next. Standardize on a specific error-reporting 
        media type .  While you <em>can</em> create your own error structure, I 
        recommend using documented, accepted standards. This will make clients 
        more re-usable, and make many of your decisions for you.
    </li>

    <li>
        Provide detailed information as to what went wrong, and what steps I 
        may be able to take next. Provide documentation for each type of error, 
        and link to that documentation from your error payloads.
    </li>

</ul>

<p>
    Which brings me to...
</p>

<h2>Next time</h2>

<p>
    I realize I still haven't covered anything specific to ZF2, but I'll start 
    next time, when I cover the next topic: documenting your API. An 
    undocumented API is a useless API, so it's good to start baking 
    documentation in immediately. I'll survey some of the possibilities and how 
    they can be implemented in ZF2 in the next installment, and then we can get 
    our hands dirty with actual API development.
</p>

<h3>Updates</h3>

<p>
    <em>Note: I'll update this post with links to the other posts in the series 
    as I publish them.</em>
</p>

<ul>
    <li><a href="/blog/2013-02-11-restful-apis-with-zf2-part-1.html">Part 1</a></li>
    <li><a href="/blog/2013-02-25-restful-apis-with-zf2-part-3.html">Part 3</a></li>
</ul>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
  </channel>
</rss>
